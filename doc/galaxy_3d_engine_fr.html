<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy3DEngine - Documentation API</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --code-bg: #2c3e50;
            --code-color: #ecf0f1;
            --border-color: #bdc3c7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-color);
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
        }

        nav {
            position: sticky;
            top: 2rem;
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        nav h2 {
            font-size: 1.3rem;
            margin-bottom: 1rem;
            color: var(--secondary-color);
        }

        nav ul {
            list-style: none;
        }

        nav ul li {
            margin-bottom: 0.5rem;
        }

        nav ul ul {
            margin-left: 1rem;
            margin-top: 0.5rem;
            display: none;
        }

        nav ul ul.expanded {
            display: block;
        }

        nav a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.3s;
        }

        nav a:hover {
            color: var(--secondary-color);
        }

        .toc-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
        }

        .toc-toggle::before {
            content: '‚ñ∏';
            display: inline-block;
            margin-right: 0.5rem;
            transition: transform 0.3s;
        }

        .toc-toggle.expanded::before {
            content: '‚ñº';
        }

        main {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        section {
            margin-bottom: 3rem;
        }

        section h2 {
            font-size: 2rem;
            color: var(--secondary-color);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        section h3 {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin: 1.5rem 0 0.5rem 0;
        }

        .api-item {
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .api-item h3 {
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            padding: 1rem;
            margin: 0;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .api-item h3:hover {
            background: linear-gradient(to right, #e9ecef, #dee2e6);
        }

        .api-item h3::after {
            content: '‚ñº';
            font-size: 0.8rem;
            transition: transform 0.3s;
        }

        .api-item h3.active::after {
            transform: rotate(-180deg);
        }

        .summary {
            font-weight: normal;
            color: #6c757d;
            font-size: 0.9rem;
            margin-left: 1rem;
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 1rem;
        }

        .accordion-content.active {
            max-height: 2000px;
            padding: 1rem;
        }

        .accordion-content p {
            margin-bottom: 1rem;
        }

        pre {
            background: var(--code-bg);
            color: var(--code-color);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
        }

        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .warning {
            background: #f8d7da;
            border-left: 4px solid var(--accent-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>üåå Galaxy3DEngine</h1>
        <p>Moteur de Rendu 3D Multi-API en Rust - Documentation API</p>
    </header>

    <div class="container">
        <nav id="toc">
            <h2>üìë Table des Mati√®res</h2>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('galaxy3dengine-section')">galaxy_3d_engine::galaxy3d::Engine</span>
                    <ul id="galaxy3dengine-section">
                        <li><a href="#galaxy3dengine-initialization">Initialisation</a></li>
                        <li><a href="#galaxy3dengine-renderer-management">Gestion du Renderer</a></li>
                        <li><a href="#galaxy3dengine-resource-manager">Resource Manager</a></li>
                    </ul>
                </li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('renderer-section')">Renderer</span>
                    <ul id="renderer-section">
                        <li><a href="#renderer-creation">Cr√©ation</a></li>
                        <li><a href="#renderer-resources">Ressources</a></li>
                        <li><a href="#renderer-submission">Soumission</a></li>
                    </ul>
                </li>
                <li><a href="#command-list">Command List</a></li>
                <li><a href="#swapchain">Swapchain</a></li>
                <li><a href="#render-target">Render Target</a></li>
                <li><a href="#render-pass">Render Pass</a></li>
                <li><a href="#pipeline">Pipeline</a></li>
                <li><a href="#buffer">Buffer</a></li>
                <li><a href="#texture">Texture</a></li>
                <li><a href="#shader">Shader</a></li>
                <li><a href="#descriptor-set">Descriptor Set</a></li>
            </ul>
        </nav>

        <main>
            <!-- Introduction -->
            <section id="introduction">
                <h2>Introduction</h2>
                <p>
                    Galaxy3DEngine est un moteur de rendu 3D moderne construit en Rust avec une couche d'abstraction multi-API.
                    Supporte actuellement Vulkan, avec un support pr√©vu pour Direct3D 12.
                </p>
                <p>
                    L'API est con√ßue avec une s√©paration claire entre le rendu et la pr√©sentation, permettant :
                </p>
                <ul>
                    <li>Rendu vers texture (render-to-texture)</li>
                    <li>Rendu multi-passes</li>
                    <li>Effets de post-traitement</li>
                    <li>Deferred shading</li>
                </ul>
                <div class="note">
                    <strong>Note :</strong> Tous les objets de l'API sont bas√©s sur des traits et retourn√©s en tant que <code>Arc&lt;dyn Trait&gt;</code> pour l'abstraction du backend.
                </div>
            </section>

            <!-- galaxy_3d_engine::galaxy3d::Engine -->
            <section id="galaxy3dengine">
                <a href="#toc" class="back-to-toc">‚Üë Table des Mati√®res</a>
                <h2>galaxy_3d_engine::galaxy3d::Engine</h2>
                <p>Gestionnaire de singletons pour les sous-syst√®mes du moteur. Fournit un acc√®s global au renderer et g√®re le cycle de vie de tous les singletons du moteur.</p>

                <h3 id="galaxy3dengine-initialization">Initialisation</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-initialize')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::initialize()</span>
                        <span class="summary">Initialise le moteur (appeler une fois au d√©marrage)</span>
                    </h3>
                    <div id="galaxy3dengine-initialize" class="accordion-content">
                        <p>Initialise l'√©tat global du moteur. Doit √™tre appel√© une fois avant de cr√©er des sous-syst√®mes.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn initialize() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialiser le moteur
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // ... cr√©er le renderer et autres sous-syst√®mes ...

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-shutdown')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::shutdown()</span>
                        <span class="summary">Arr√™te le moteur et d√©truit tous les singletons</span>
                    </h3>
                    <div id="galaxy3dengine-shutdown" class="accordion-content">
                        <p>D√©truit tous les singletons du moteur et nettoie l'√©tat global. Appeler √† l'arr√™t de l'application.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn shutdown()</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() {
    galaxy_3d_engine::galaxy3d::Engine::initialize().unwrap();

    // ... code de l'application ...

    // Nettoyage
    galaxy_3d_engine::galaxy3d::Engine::shutdown();
}</code></pre>
                    </div>
                </div>

                <h3 id="galaxy3dengine-renderer-management">Gestion du Renderer</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-create-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::create_renderer()</span>
                        <span class="summary">Cr√©e et enregistre le singleton renderer</span>
                    </h3>
                    <div id="galaxy3dengine-create-renderer" class="accordion-content">
                        <p>
                            Cr√©e un singleton renderer √† partir de n'importe quel type impl√©mentant le trait Renderer.
                            Le renderer est automatiquement envelopp√© dans Arc&lt;Mutex&gt; pour un acc√®s thread-safe.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn create_renderer&lt;R: Renderer + 'static&gt;(renderer: R) -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Param√®tres</h4>
                        <ul>
                            <li><code>renderer</code> - N'importe quel type impl√©mentant le trait Renderer</li>
                        </ul>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Moteur non initialis√©</li>
                            <li>Renderer existe d√©j√†</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::{galaxy_3d_engine::galaxy3d::Engine, galaxy_3d_engine::galaxy3d::render::Config};
use galaxy_3d_engine_renderer_vulkan::galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // Cr√©er un renderer Vulkan
    let config = galaxy_3d_engine::galaxy3d::render::Config::default();
    let vulkan_renderer = galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new(&window, config)?;

    // Enregistrer comme singleton (API simplifi√©e)
    galaxy_3d_engine::galaxy3d::Engine::create_renderer(vulkan_renderer)?;

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::renderer()</span>
                        <span class="summary">Obtient le singleton renderer global</span>
                    </h3>
                    <div id="galaxy3dengine-renderer" class="accordion-content">
                        <p>Retourne un pointeur partag√© vers le singleton renderer. Le renderer est envelopp√© dans un Mutex pour un acc√®s mutable thread-safe.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn renderer() -> galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;Mutex&lt;dyn Renderer&gt;&gt;&gt;</code></pre>
                        <h4>Retour</h4>
                        <p>Un pointeur partag√© vers le renderer envelopp√© dans un Mutex</p>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Moteur non initialis√©</li>
                            <li>Renderer non cr√©√©</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::{galaxy_3d_engine::galaxy3d::Engine, BufferDesc, BufferUsage};

fn create_vertex_buffer() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Acc√®s au renderer global
    let renderer = galaxy_3d_engine::galaxy3d::Engine::renderer()?;
    let mut renderer_guard = renderer.lock().unwrap();

    // Cr√©er un buffer
    let buffer = renderer_guard.create_buffer(BufferDesc {
        size: 1024,
        usage: BufferUsage::Vertex,
    })?;

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-destroy-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::destroy_renderer()</span>
                        <span class="summary">D√©truit le singleton renderer</span>
                    </h3>
                    <div id="galaxy3dengine-destroy-renderer" class="accordion-content">
                        <p>
                            Supprime le singleton renderer du stockage global. Les r√©f√©rences existantes au renderer
                            (pointeurs Arc) resteront valides jusqu'√† ce qu'elles soient lib√©r√©es.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn destroy_renderer() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // ... utiliser le renderer ...

    // Nettoyage
    galaxy_3d_engine::galaxy3d::Engine::destroy_renderer()?;
    galaxy_3d_engine::galaxy3d::Engine::shutdown();

    Ok(())
}</code></pre>
                    </div>
                </div>

                <h3 id="galaxy3dengine-resource-manager">Resource Manager</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-create-resource-manager')">
                        <span>Engine::create_resource_manager()</span>
                        <span class="summary">Cr√©e le singleton resource manager</span>
                    </h3>
                    <div id="galaxy3dengine-create-resource-manager" class="accordion-content">
                        <p>
                            Cr√©e un nouveau ResourceManager et l'enregistre comme singleton global.
                            Le ResourceManager fournit un stockage centralis√© et un acc√®s aux ressources du moteur.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn create_resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Engine non initialis√©</li>
                            <li>ResourceManager d√©j√† existant</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;
    // Le ResourceManager est maintenant disponible globalement
    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-resource-manager')">
                        <span>Engine::resource_manager()</span>
                        <span class="summary">R√©cup√®re le singleton resource manager</span>
                    </h3>
                    <div id="galaxy3dengine-resource-manager" class="accordion-content">
                        <p>
                            Retourne un pointeur partag√© vers le ResourceManager envelopp√© dans un Mutex pour un acc√®s thread-safe.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;Mutex&lt;ResourceManager&gt;&gt;&gt;</code></pre>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Engine non initialis√©</li>
                            <li>ResourceManager non cr√©√©</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;

    let rm = Engine::resource_manager()?;
    let rm_guard = rm.lock().unwrap();
    // Utiliser rm_guard...

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-destroy-resource-manager')">
                        <span>Engine::destroy_resource_manager()</span>
                        <span class="summary">D√©truit le singleton resource manager</span>
                    </h3>
                    <div id="galaxy3dengine-destroy-resource-manager" class="accordion-content">
                        <p>
                            Supprime le singleton resource manager du stockage global.
                            Doit √™tre appel√© avant de d√©truire le renderer, car les ressources peuvent r√©f√©rencer des objets GPU.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn destroy_resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;

    // ... utiliser les ressources ...

    // Nettoyage (resource manager avant renderer)
    Engine::destroy_resource_manager()?;
    Engine::destroy_renderer()?;
    Engine::shutdown();

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="note">
                    <strong>Thread Safety :</strong> Engine utilise OnceLock + RwLock pour une gestion thread-safe des singletons.
                    Plusieurs threads peuvent acc√©der au renderer et au resource manager en toute s√©curit√© simultan√©ment (avec verrouillage mutex interne).
                </div>
            </section>

            <!-- Renderer -->
            <section id="renderer">
                <a href="#toc" class="back-to-toc">‚Üë Table des Mati√®res</a>
                <h2>Renderer</h2>
                <p>L'interface factory principale pour cr√©er des ressources, command lists, swapchains, et soumettre du travail au GPU.</p>

                <h3 id="renderer-creation">Cr√©ation & Initialisation</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('renderer-new')">
                        <span>galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new()</span>
                        <span class="summary">Cr√©e une nouvelle instance de renderer Vulkan</span>
                    </h3>
                    <div id="renderer-new" class="accordion-content">
                        <p>
                            Cr√©e et initialise un nouveau renderer Vulkan. C'est le point d'entr√©e du moteur de rendu.
                            Configure l'instance Vulkan, le physical device, le logical device, et l'allocateur m√©moire.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>window: &Window</code> - Le handle de fen√™tre winit</li>
                            <li><code>config: galaxy_3d_engine::galaxy3d::render::Config</code> - Configuration du renderer (validation layers, etc.)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn Renderer&gt;&gt;</code></p>
                        <pre><code class="language-rust">use galaxy_3d_engine_renderer_vulkan::galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer;
use galaxy_3d_engine::{Renderer, galaxy_3d_engine::galaxy3d::render::Config};

let config = galaxy_3d_engine::galaxy3d::render::Config {
    enable_validation: true,
};

let renderer = galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new(&window, config)?;
</code></pre>
                    </div>
                </div>

                <h3 id="renderer-resources">Gestion des Ressources</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-buffer')">
                        <span>create_buffer()</span>
                        <span class="summary">Cr√©e un buffer GPU (vertex, index, uniform)</span>
                    </h3>
                    <div id="create-buffer" class="accordion-content">
                        <p>
                            Cr√©e un buffer GPU pour stocker des donn√©es de vertices, d'indices, ou d'uniformes.
                            Le buffer est allou√© avec gpu-allocator et peut √™tre mis √† jour apr√®s cr√©ation.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: BufferDesc</code> - Description du buffer (taille, usage, donn√©es)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;&gt;</code></p>
                        <pre><code class="language-rust">let vertex_data: Vec&lt;f32&gt; = vec![/* positions des vertices */];

let vertex_buffer = renderer.create_buffer(BufferDesc {
    size: (vertex_data.len() * std::mem::size_of::&lt;f32&gt;()) as u64,
    usage: BufferUsage::VERTEX,
    data: Some(bytemuck::cast_slice(&vertex_data)),
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-texture')">
                        <span>create_texture()</span>
                        <span class="summary">Cr√©e une texture GPU avec donn√©es initiales optionnelles</span>
                    </h3>
                    <div id="create-texture" class="accordion-content">
                        <p>
                            Cr√©e une texture GPU et upload optionnellement des donn√©es d'image initiales.
                            G√®re les transitions de layout et le staging buffer en interne.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: TextureDesc</code> - Description de la texture (largeur, hauteur, format, donn√©es)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Texture&gt;&gt;</code></p>
                        <pre><code class="language-rust">let image_data: Vec&lt;u8&gt; = load_image("texture.png")?;

let texture = renderer.create_texture(TextureDesc {
    width: 512,
    height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    data: Some(image_data),
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-shader')">
                        <span>create_shader()</span>
                        <span class="summary">Cr√©e un module shader depuis du bytecode SPIR-V</span>
                    </h3>
                    <div id="create-shader" class="accordion-content">
                        <p>
                            Cr√©e un module shader depuis du bytecode SPIR-V compil√©.
                            Supporte les stages vertex, fragment, compute, et autres.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: ShaderDesc</code> - Description du shader (stage, code SPIR-V)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Shader&gt;&gt;</code></p>
                        <pre><code class="language-rust">let vertex_spirv = include_bytes!("shaders/shader.vert.spv");

let vertex_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Vertex,
    code: vertex_spirv,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-pipeline')">
                        <span>create_pipeline()</span>
                        <span class="summary">Cr√©e un pipeline graphique avec shaders et √©tat</span>
                    </h3>
                    <div id="create-pipeline" class="accordion-content">
                        <p>
                            Cr√©e un pipeline graphique complet incluant shaders, layout de vertices,
                            topologie primitive, push constants, descriptor sets, et configuration de blending.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: PipelineDesc</code> - Description du pipeline</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;&gt;</code></p>
                        <pre><code class="language-rust">let pipeline = renderer.create_pipeline(PipelineDesc {
    vertex_shader: vertex_shader.clone(),
    fragment_shader: fragment_shader.clone(),
    vertex_layout: VertexLayout {
        bindings: vec![
            VertexBinding {
                binding: 0,
                stride: 20, // 3 floats (pos) + 2 floats (uv)
                input_rate: VertexInputRate::Vertex,
            },
        ],
        attributes: vec![
            VertexAttribute {
                location: 0,
                binding: 0,
                format: VertexFormat::Float3,
                offset: 0,
            },
            VertexAttribute {
                location: 1,
                binding: 0,
                format: VertexFormat::Float2,
                offset: 12,
            },
        ],
    },
    topology: PrimitiveTopology::TriangleList,
    push_constant_ranges: vec![],
    descriptor_set_layouts: vec![],
    enable_blending: false,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-descriptor-set')">
                        <span>create_descriptor_set_for_texture()</span>
                        <span class="summary">Cr√©e un descriptor set li√© √† une texture</span>
                    </h3>
                    <div id="create-descriptor-set" class="accordion-content">
                        <p>
                            Cr√©e un descriptor set avec un binding de sampler de texture.
                            Utilis√© pour lier des textures aux shaders.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>texture: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Texture&gt;</code> - La texture √† lier</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::DescriptorSet&gt;&gt;</code></p>
                        <pre><code class="language-rust">let texture = renderer.create_texture(texture_desc)?;
let descriptor_set = renderer.create_descriptor_set_for_texture(&texture)?;

// Plus tard, dans le rendu:
command_list.bind_descriptor_sets(&pipeline, &[&descriptor_set])?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-command-list')">
                        <span>create_command_list()</span>
                        <span class="summary">Cr√©e une command list r√©utilisable pour enregistrer des commandes GPU</span>
                    </h3>
                    <div id="create-command-list" class="accordion-content">
                        <p>
                            Cr√©e une command list (command buffer) pour enregistrer des commandes de rendu.
                            Les command lists peuvent √™tre r√©utilis√©es sur plusieurs frames.
                        </p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::CommandList&gt;&gt;</code></p>
                        <pre><code class="language-rust">let command_list = renderer.create_command_list()?;

// Les command lists peuvent √™tre r√©utilis√©es
let command_lists = [
    renderer.create_command_list()?,
    renderer.create_command_list()?,
];

let current_cmd = &command_lists[frame_index % 2];
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-swapchain')">
                        <span>create_swapchain()</span>
                        <span class="summary">Cr√©e une swapchain pour pr√©senter √† une fen√™tre</span>
                    </h3>
                    <div id="create-swapchain" class="accordion-content">
                        <p>
                            Cr√©e une swapchain attach√©e √† une fen√™tre pour pr√©senter les images rendues.
                            G√®re l'acquisition d'images et la pr√©sentation avec synchronisation appropri√©e.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>window: &Window</code> - La fen√™tre vers laquelle pr√©senter</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Swapchain&gt;&gt;</code></p>
                        <pre><code class="language-rust">let swapchain = renderer.create_swapchain(&window)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-render-pass')">
                        <span>create_render_pass()</span>
                        <span class="summary">Cr√©e une configuration de render pass</span>
                    </h3>
                    <div id="create-render-pass" class="accordion-content">
                        <p>
                            Cr√©e une configuration de render pass d√©finissant les attachments et d√©pendances de subpasses.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: RenderPassDesc</code> - Description du render pass</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderPass&gt;&gt;</code></p>
                        <pre><code class="language-rust">let render_pass = renderer.create_render_pass(RenderPassDesc {
    color_attachments: vec![
        ColorAttachmentDesc {
            format: swapchain.format(),
            load_op: LoadOp::Clear,
            store_op: StoreOp::Store,
        },
    ],
    depth_attachment: None,
})?;
</code></pre>
                    </div>
                </div>

                <h3 id="renderer-submission">Soumission de Commandes</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('submit-with-sync')">
                        <span>submit_with_sync()</span>
                        <span class="summary">Soumet la command list avec synchronisation swapchain</span>
                    </h3>
                    <div id="submit-with-sync" class="accordion-content">
                        <p>
                            Soumet une command list √† la queue GPU avec synchronisation appropri√©e pour la pr√©sentation swapchain.
                            Attend le s√©maphore image disponible et signale le s√©maphore rendu termin√©.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>command_list: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::CommandList&gt;</code> - La command list √† soumettre</li>
                            <li><code>sync_info: &SwapchainSyncInfo</code> - Info de synchronisation depuis la swapchain</li>
                            <li><code>image_index: u32</code> - Index de l'image swapchain</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">// Boucle de rendu typique
let (image_index, render_target) = swapchain.acquire_next_image()?;

command_list.begin()?;
command_list.begin_render_pass(&render_pass, &render_target, &clear_values)?;
// ... enregistrer les commandes de dessin ...
command_list.end_render_pass()?;
command_list.end()?;

let sync_info = swapchain.sync_info();
renderer.submit_with_sync(&command_list, &sync_info, image_index)?;

swapchain.present(image_index)?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Command List -->
            <section id="command-list">
                <h2>Command List</h2>
                <p>Voir <a href="#create-command-list">Renderer::create_command_list()</a> pour la cr√©ation de command list.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::CommandList</h3>
                <p>Interface pour enregistrer des commandes de rendu. Les command lists sont r√©utilisables et doivent √™tre d√©marr√©es/termin√©es √† chaque frame.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-begin')">
                        <span>begin()</span>
                        <span class="summary">D√©marre l'enregistrement de commandes</span>
                    </h3>
                    <div id="cmd-begin" class="accordion-content">
                        <p>D√©marre l'enregistrement de commandes dans la command list. Doit √™tre appel√© avant toute autre commande d'enregistrement.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.begin()?;
// ... enregistrer les commandes ...
command_list.end()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-begin-render-pass')">
                        <span>begin_render_pass()</span>
                        <span class="summary">D√©marre un render pass</span>
                    </h3>
                    <div id="cmd-begin-render-pass" class="accordion-content">
                        <p>D√©marre un render pass avec la render target et les valeurs de clear sp√©cifi√©es.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>render_pass: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderPass&gt;</code></li>
                            <li><code>render_target: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderTarget&gt;</code></li>
                            <li><code>clear_values: &[ClearValue]</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let clear_values = [
    ClearValue::Color([0.0, 0.0, 0.0, 1.0]), // Couleur de clear noir
];

command_list.begin_render_pass(&render_pass, &render_target, &clear_values)?;
// ... commandes de dessin ...
command_list.end_render_pass()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-pipeline')">
                        <span>bind_pipeline()</span>
                        <span class="summary">Lie un pipeline graphique</span>
                    </h3>
                    <div id="cmd-bind-pipeline" class="accordion-content">
                        <p>Lie un pipeline graphique pour les commandes de dessin suivantes.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>pipeline: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_pipeline(&pipeline)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-vertex-buffer')">
                        <span>bind_vertex_buffer()</span>
                        <span class="summary">Lie un buffer de vertices</span>
                    </h3>
                    <div id="cmd-bind-vertex-buffer" class="accordion-content">
                        <p>Lie un buffer de vertices √† un slot de binding.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>buffer: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;</code></li>
                            <li><code>binding: u32</code> - Slot de binding (g√©n√©ralement 0)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_vertex_buffer(&vertex_buffer, 0)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-index-buffer')">
                        <span>bind_index_buffer()</span>
                        <span class="summary">Lie un buffer d'indices</span>
                    </h3>
                    <div id="cmd-bind-index-buffer" class="accordion-content">
                        <p>Lie un buffer d'indices pour le dessin index√©.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>buffer: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;</code></li>
                            <li><code>offset: u64</code> - Offset en octets (g√©n√©ralement 0)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_index_buffer(&index_buffer, 0)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-descriptor-sets')">
                        <span>bind_descriptor_sets()</span>
                        <span class="summary">Lie des descriptor sets (textures, uniforms)</span>
                    </h3>
                    <div id="cmd-bind-descriptor-sets" class="accordion-content">
                        <p>Lie des descriptor sets contenant des textures et uniform buffers.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>pipeline: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;</code></li>
                            <li><code>descriptor_sets: &[&Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::DescriptorSet&gt;]</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_descriptor_sets(&pipeline, &[&texture_descriptor])?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-push-constants')">
                        <span>push_constants()</span>
                        <span class="summary">Met √† jour les donn√©es de push constants</span>
                    </h3>
                    <div id="cmd-push-constants" class="accordion-content">
                        <p>Met √† jour les donn√©es de push constants pour des param√®tres rapides par draw (transforms, temps, etc.).</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>offset: u32</code> - Offset dans le bloc de push constants</li>
                            <li><code>data: &[u8]</code> - Octets bruts √† pousser</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let time: f32 = elapsed_time;
command_list.push_constants(0, &time.to_le_bytes())?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-draw')">
                        <span>draw()</span>
                        <span class="summary">√âmet un draw call</span>
                    </h3>
                    <div id="cmd-draw" class="accordion-content">
                        <p>Dessine des vertices non-index√©s.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>vertex_count: u32</code></li>
                            <li><code>first_vertex: u32</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.draw(3, 0)?; // Dessine 3 vertices (1 triangle)
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-draw-indexed')">
                        <span>draw_indexed()</span>
                        <span class="summary">√âmet un draw call index√©</span>
                    </h3>
                    <div id="cmd-draw-indexed" class="accordion-content">
                        <p>Dessine de la g√©om√©trie index√©e.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>index_count: u32</code></li>
                            <li><code>first_index: u32</code></li>
                            <li><code>vertex_offset: i32</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.draw_indexed(6, 0, 0)?; // Dessine 6 indices (2 triangles)
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-set-viewport')">
                        <span>set_viewport()</span>
                        <span class="summary">D√©finit le viewport</span>
                    </h3>
                    <div id="cmd-set-viewport" class="accordion-content">
                        <p>D√©finit le viewport pour le rendu.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>viewport: Viewport</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.set_viewport(Viewport {
    x: 0.0,
    y: 0.0,
    width: 800.0,
    height: 600.0,
    min_depth: 0.0,
    max_depth: 1.0,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-end-render-pass')">
                        <span>end_render_pass()</span>
                        <span class="summary">Termine le render pass actuel</span>
                    </h3>
                    <div id="cmd-end-render-pass" class="accordion-content">
                        <p>Termine le render pass actuellement actif.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.end_render_pass()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-end')">
                        <span>end()</span>
                        <span class="summary">Termine l'enregistrement de commandes</span>
                    </h3>
                    <div id="cmd-end" class="accordion-content">
                        <p>Termine l'enregistrement et finalise la command list pour soumission.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.end()?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Swapchain -->
            <section id="swapchain">
                <h2>Swapchain</h2>
                <p>Voir <a href="#create-swapchain">Renderer::create_swapchain()</a> pour la cr√©ation de swapchain.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Swapchain</h3>
                <p>G√®re la pr√©sentation √† une fen√™tre avec acquisition et pr√©sentation d'images synchronis√©es.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-acquire')">
                        <span>acquire_next_image()</span>
                        <span class="summary">Acquiert la prochaine image swapchain pour le rendu</span>
                    </h3>
                    <div id="swap-acquire" class="accordion-content">
                        <p>Acquiert la prochaine image disponible de la swapchain. Retourne l'index d'image et une render target.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;(u32, Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderTarget&gt;)&gt;</code></p>
                        <pre><code class="language-rust">let (image_index, render_target) = swapchain.acquire_next_image()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-present')">
                        <span>present()</span>
                        <span class="summary">Pr√©sente l'image rendue √† l'√©cran</span>
                    </h3>
                    <div id="swap-present" class="accordion-content">
                        <p>Pr√©sente l'image √† l'index sp√©cifi√© √† l'√©cran apr√®s que le rendu soit termin√©.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>image_index: u32</code> - L'index d'image depuis acquire_next_image</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">swapchain.present(image_index)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-sync-info')">
                        <span>sync_info()</span>
                        <span class="summary">Obtient les informations de synchronisation pour la soumission</span>
                    </h3>
                    <div id="swap-sync-info" class="accordion-content">
                        <p>Retourne les informations de synchronisation n√©cessaires pour submit_with_sync().</p>
                        <p><strong>Retourne :</strong> <code>SwapchainSyncInfo</code></p>
                        <pre><code class="language-rust">let sync_info = swapchain.sync_info();
renderer.submit_with_sync(&command_list, &sync_info, image_index)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-format')">
                        <span>format()</span>
                        <span class="summary">Obtient le format d'image de la swapchain</span>
                    </h3>
                    <div id="swap-format" class="accordion-content">
                        <p>Retourne le format pixel des images swapchain.</p>
                        <p><strong>Retourne :</strong> <code>TextureFormat</code></p>
                        <pre><code class="language-rust">let format = swapchain.format();
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Render Target -->
            <section id="render-target">
                <h2>Render Target</h2>
                <p>Repr√©sente une destination de rendu (soit image swapchain soit texture).</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::RenderTarget</h3>
                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::RenderTarget est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de render target. Les render targets sont typiquement obtenus depuis swapchain.acquire_next_image() ou cr√©√©s depuis des textures.
                </div>
            </section>

            <!-- Render Pass -->
            <section id="render-pass">
                <h2>Render Pass</h2>
                <p>Voir <a href="#create-render-pass">Renderer::create_render_pass()</a> pour la cr√©ation de render pass.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::RenderPass</h3>
                <p>D√©finit la configuration de rendu incluant les attachments couleur/profondeur et les op√©rations load/store.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::RenderPass est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de render pass.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('renderpass-desc')">
                        <span>RenderPassDesc</span>
                        <span class="summary">Structure de description du render pass</span>
                    </h3>
                    <div id="renderpass-desc" class="accordion-content">
                        <p>D√©crit une configuration de render pass.</p>
                        <pre><code class="language-rust">let render_pass = renderer.create_render_pass(RenderPassDesc {
    color_attachments: vec![
        ColorAttachmentDesc {
            format: swapchain.format(),
            load_op: LoadOp::Clear,   // Clear au chargement
            store_op: StoreOp::Store, // Stocker le r√©sultat
        },
    ],
    depth_attachment: None,
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Pipeline -->
            <section id="pipeline">
                <h2>Pipeline</h2>
                <p>Voir <a href="#create-pipeline">Renderer::create_pipeline()</a> pour la cr√©ation de pipeline.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Pipeline</h3>
                <p>√âtat du pipeline graphique incluant shaders, layout de vertices, topologie, et blending.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::Pipeline est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de pipeline.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('pipeline-desc')">
                        <span>PipelineDesc</span>
                        <span class="summary">Structure de description du pipeline</span>
                    </h3>
                    <div id="pipeline-desc" class="accordion-content">
                        <p>Configuration compl√®te du pipeline incluant :</p>
                        <ul>
                            <li>Shaders vertex et fragment</li>
                            <li>Layout de vertices (bindings et attributs)</li>
                            <li>Topologie primitive</li>
                            <li>Ranges de push constants</li>
                            <li>Layouts de descriptor sets</li>
                            <li>Configuration de blending</li>
                        </ul>
                        <pre><code class="language-rust">let pipeline = renderer.create_pipeline(PipelineDesc {
    vertex_shader: vertex_shader.clone(),
    fragment_shader: fragment_shader.clone(),
    vertex_layout: VertexLayout {
        bindings: vec![
            VertexBinding {
                binding: 0,
                stride: 20,
                input_rate: VertexInputRate::Vertex,
            },
        ],
        attributes: vec![
            VertexAttribute {
                location: 0,
                binding: 0,
                format: VertexFormat::Float3,
                offset: 0,
            },
        ],
    },
    topology: PrimitiveTopology::TriangleList,
    push_constant_ranges: vec![
        PushConstantRange {
            stages: vec![ShaderStage::Vertex],
            offset: 0,
            size: 16, // 4 floats
        },
    ],
    descriptor_set_layouts: vec![],
    enable_blending: true, // Activer alpha blending
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Buffer -->
            <section id="buffer">
                <h2>Buffer</h2>
                <p>Voir <a href="#create-buffer">Renderer::create_buffer()</a> pour la cr√©ation de buffer.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Buffer</h3>
                <p>Buffer GPU pour stocker des donn√©es de vertices, d'indices, ou d'uniformes.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('buffer-update')">
                        <span>update()</span>
                        <span class="summary">Met √† jour les donn√©es du buffer</span>
                    </h3>
                    <div id="buffer-update" class="accordion-content">
                        <p>Met √† jour le contenu du buffer avec de nouvelles donn√©es.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>offset: u64</code> - Offset en octets</li>
                            <li><code>data: &[u8]</code> - Nouvelles donn√©es</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let new_vertex_data: Vec&lt;f32&gt; = vec![/* vertices mis √† jour */];
vertex_buffer.update(0, bytemuck::cast_slice(&new_vertex_data))?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Texture -->
            <section id="texture">
                <h2>Texture</h2>
                <p>Voir <a href="#create-texture">Renderer::create_texture()</a> pour la cr√©ation de texture.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Texture</h3>
                <p>Texture GPU pour le sampling dans les shaders.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::Texture est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de texture.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-formats')">
                        <span>TextureFormat</span>
                        <span class="summary">Formats de texture support√©s</span>
                    </h3>
                    <div id="texture-formats" class="accordion-content">
                        <p>Formats de texture courants :</p>
                        <ul>
                            <li><code>R8G8B8A8_SRGB</code> - RGBA 8-bit avec espace couleur sRGB</li>
                            <li><code>R8G8B8A8_UNORM</code> - RGBA 8-bit lin√©aire</li>
                            <li><code>B8G8R8A8_SRGB</code> - BGRA 8-bit avec sRGB (courant pour swapchains)</li>
                        </ul>
                        <pre><code class="language-rust">let texture = renderer.create_texture(TextureDesc {
    width: 512,
    height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    data: Some(image_data),
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Shader -->
            <section id="shader">
                <h2>Shader</h2>
                <p>Voir <a href="#create-shader">Renderer::create_shader()</a> pour la cr√©ation de shader.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Shader</h3>
                <p>Module shader compil√© (bytecode SPIR-V).</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::Shader est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de shader.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('shader-stages')">
                        <span>ShaderStage</span>
                        <span class="summary">Types de stages de shader</span>
                    </h3>
                    <div id="shader-stages" class="accordion-content">
                        <p>Stages de shader support√©s :</p>
                        <ul>
                            <li><code>ShaderStage::Vertex</code> - Shader vertex</li>
                            <li><code>ShaderStage::Fragment</code> - Shader fragment/pixel</li>
                            <li><code>ShaderStage::Compute</code> - Shader compute (futur)</li>
                        </ul>
                        <pre><code class="language-rust">let vertex_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Vertex,
    code: include_bytes!("shader.vert.spv"),
})?;

let fragment_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Fragment,
    code: include_bytes!("shader.frag.spv"),
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Descriptor Set -->
            <section id="descriptor-set">
                <h2>Descriptor Set</h2>
                <p>Voir <a href="#create-descriptor-set">Renderer::create_descriptor_set_for_texture()</a> pour la cr√©ation de descriptor set.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::DescriptorSet</h3>
                <p>Lie des ressources (textures, uniform buffers) aux shaders.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::DescriptorSet est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de descriptor set. Actuellement, les descriptor sets sont cr√©√©s sp√©cifiquement pour les textures en utilisant <code>create_descriptor_set_for_texture()</code>. Les versions futures supporteront des layouts de descripteurs personnalis√©s.
                </div>

                <pre><code class="language-rust">// Cr√©er texture et descriptor set
let texture = renderer.create_texture(texture_desc)?;
let descriptor_set = renderer.create_descriptor_set_for_texture(&texture)?;

// Utiliser dans le rendu
command_list.bind_descriptor_sets(&pipeline, &[&descriptor_set])?;
</code></pre>
            </section>

            <!-- Logger -->
            <section id="logger">
                <h2>Logger</h2>
                <p>Voir <a href="#set-logger">Engine::set_logger()</a> pour l'installation du logger.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::log::Logger</h3>
                <p>Interface de logger personnalis√© pour intercepter et router les logs internes du moteur.</p>

                <div class="note">
                    <strong>Note :</strong> Le trait Logger permet aux utilisateurs d'impl√©menter des backends de logging personnalis√©s (par ex. tracing, slog, log4rs) pour capturer les logs internes du Galaxy3D Engine. Le moteur utilise ce logger pour tous ses messages internes via des macros internes (non expos√©es dans l'API publique).
                </div>

                <h4>D√©finition du Trait</h4>
                <pre><code class="language-rust">pub trait Logger: Send + Sync {
    fn log(&self, entry: &LogEntry);
}

pub struct LogEntry&lt;'a&gt; {
    pub severity: LogSeverity,
    pub source: &'a str,       // ex: "galaxy3d::vulkan::Renderer"
    pub message: &'a str,
    pub file: Option&lt;&'a str&gt;, // Chemin du fichier (seulement pour les erreurs)
    pub line: Option&lt;u32&gt;,     // Num√©ro de ligne (seulement pour les erreurs)
}

pub enum LogSeverity {
    Trace,   // Informations de d√©bogage verbeux
    Debug,   // Informations de d√©bogage d√©taill√©es
    Info,    // Messages informatifs
    Warn,    // Messages d'avertissement
    Error,   // Messages d'erreur
}</code></pre>

                <h4>Exemple : Impl√©mentation TracingLogger</h4>
                <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::log::{Logger, LogEntry, LogSeverity};
use tracing::Level;

pub struct TracingLogger {
    // ... champs ...
}

impl Logger for TracingLogger {
    fn log(&self, entry: &LogEntry) {
        // Convertir LogSeverity vers tracing::Level
        let level = match entry.severity {
            LogSeverity::Trace => Level::TRACE,
            LogSeverity::Debug => Level::DEBUG,
            LogSeverity::Info => Level::INFO,
            LogSeverity::Warn => Level::WARN,
            LogSeverity::Error => Level::ERROR,
        };

        // Formater le message avec le module source
        let full_message = if let (Some(file), Some(line)) = (entry.file, entry.line) {
            format!("[{}] {} ({}:{})", entry.source, entry.message, file, line)
        } else {
            format!("[{}] {}", entry.source, entry.message)
        };

        // Router vers tracing
        match level {
            Level::TRACE => tracing::trace!("{}", full_message),
            Level::DEBUG => tracing::debug!("{}", full_message),
            Level::INFO => tracing::info!("{}", full_message),
            Level::WARN => tracing::warn!("{}", full_message),
            Level::ERROR => tracing::error!("{}", full_message),
        }
    }
}

// Installer le logger personnalis√©
fn main() {
    galaxy3d::Engine::initialize()?;

    let logger = TracingLogger::new("app.log")?;
    galaxy3d::Engine::set_logger(logger);

    // Tous les logs du moteur seront maintenant rout√©s vers votre logger
}</code></pre>

                <h4>DefaultLogger</h4>
                <p>Si aucun logger personnalis√© n'est install√©, le moteur utilise <code>DefaultLogger</code> qui affiche sur la console avec couleurs et horodatage :</p>
                <pre><code class="language-bash">[2026-01-31 17:18:30.120] [INFO ] [galaxy3d::vulkan::Renderer] Vulkan renderer initialized
[2026-01-31 17:18:30.234] [ERROR] [galaxy3d::vulkan::Swapchain] Failed to acquire image (vulkan_swapchain.rs:142)</code></pre>

                <div class="note">
                    <strong>Important :</strong> Les macros de logging internes du moteur (<code>engine_trace!</code>, <code>engine_debug!</code>, <code>engine_info!</code>, <code>engine_warn!</code>, <code>engine_error!</code>) sont cach√©es de l'API publique (<code>#[doc(hidden)]</code>) et ne doivent PAS √™tre utilis√©es par les applications. Les applications doivent impl√©menter le trait Logger pour capturer les logs du moteur.
                </div>
            </section>
        </main>
    </div>

    <footer>
        <p>&copy; 2026 Galaxy3DEngine - Moteur de Rendu 3D Multi-API en Rust</p>
        <p>Documentation G√©n√©r√©e</p>
    </footer>

    <script>
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            const header = content.previousElementSibling;

            // Fermer tous les autres accord√©ons
            document.querySelectorAll('.accordion-content').forEach(el => {
                if (el.id !== id) {
                    el.classList.remove('active');
                    el.previousElementSibling.classList.remove('active');
                }
            });

            // Toggle accord√©on actuel
            content.classList.toggle('active');
            header.classList.toggle('active');
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const toggle = event.target;

            section.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
    </script>
</body>
</html>
