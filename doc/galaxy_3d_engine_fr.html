<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy3DEngine - Documentation API</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --code-bg: #2c3e50;
            --code-color: #ecf0f1;
            --border-color: #bdc3c7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-color);
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
        }

        nav {
            position: sticky;
            top: 2rem;
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        nav h2 {
            font-size: 1.3rem;
            margin-bottom: 1rem;
            color: var(--secondary-color);
        }

        nav ul {
            list-style: none;
        }

        nav ul li {
            margin-bottom: 0.5rem;
        }

        nav ul ul {
            margin-left: 1rem;
            margin-top: 0.5rem;
            display: none;
        }

        nav ul ul.expanded {
            display: block;
        }

        nav a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.3s;
        }

        nav a:hover {
            color: var(--secondary-color);
        }

        .toc-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
        }

        .toc-toggle::before {
            content: '‚ñ∏';
            display: inline-block;
            margin-right: 0.5rem;
            transition: transform 0.3s;
        }

        .toc-toggle.expanded::before {
            content: '‚ñº';
        }

        main {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        section {
            margin-bottom: 3rem;
        }

        section h2 {
            font-size: 2rem;
            color: var(--secondary-color);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        section h3 {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin: 1.5rem 0 0.5rem 0;
        }

        .api-item {
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .api-item h3 {
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            padding: 1rem;
            margin: 0;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .api-item h3:hover {
            background: linear-gradient(to right, #e9ecef, #dee2e6);
        }

        .api-item h3::after {
            content: '‚ñº';
            font-size: 0.8rem;
            transition: transform 0.3s;
        }

        .api-item h3.active::after {
            transform: rotate(-180deg);
        }

        .summary {
            font-weight: normal;
            color: #6c757d;
            font-size: 0.9rem;
            margin-left: 1rem;
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 1rem;
        }

        .accordion-content.active {
            max-height: 2000px;
            padding: 1rem;
        }

        .accordion-content p {
            margin-bottom: 1rem;
        }

        pre {
            background: var(--code-bg);
            color: var(--code-color);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
        }

        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .warning {
            background: #f8d7da;
            border-left: 4px solid var(--accent-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>üåå Galaxy3DEngine</h1>
        <p>Moteur de Rendu 3D Multi-API en Rust - Documentation API</p>
    </header>

    <div class="container">
        <nav id="toc">
            <h2>üìë Table des Mati√®res</h2>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('galaxy3dengine-section')">galaxy_3d_engine::galaxy3d::Engine</span>
                    <ul id="galaxy3dengine-section">
                        <li><a href="#galaxy3dengine-initialization">Initialisation</a></li>
                        <li><a href="#galaxy3dengine-renderer-management">Gestion du Renderer</a></li>
                        <li><a href="#galaxy3dengine-resource-manager">Resource Manager</a></li>
                    </ul>
                </li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('renderer-section')">Renderer</span>
                    <ul id="renderer-section">
                        <li><a href="#renderer-creation">Cr√©ation</a></li>
                        <li><a href="#renderer-resources">Ressources</a></li>
                        <li><a href="#renderer-submission">Soumission</a></li>
                    </ul>
                </li>
                <li><a href="#command-list">Command List</a></li>
                <li><a href="#swapchain">Swapchain</a></li>
                <li><a href="#render-target">Render Target</a></li>
                <li><a href="#render-pass">Render Pass</a></li>
                <li><a href="#pipeline">Pipeline</a></li>
                <li><a href="#buffer">Buffer</a></li>
                <li><a href="#texture">Texture</a></li>
                <li><a href="#shader">Shader</a></li>
                <li><a href="#descriptor-set">Descriptor Set</a></li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('resource-texture-section')">Textures Ressource</span>
                    <ul id="resource-texture-section">
                        <li><a href="#resource-texture-trait">Trait Texture</a></li>
                        <li><a href="#resource-texture-types">Types Concrets</a></li>
                        <li><a href="#resource-texture-manager">API Texture du ResourceManager</a></li>
                    </ul>
                </li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('resource-mesh-section')">Meshes Ressource</span>
                    <ul id="resource-mesh-section">
                        <li><a href="#resource-mesh-hierarchy">Hi√©rarchie √† 4 Niveaux</a></li>
                        <li><a href="#resource-mesh-descriptors">Structures de Descripteurs</a></li>
                        <li><a href="#resource-mesh-manager">API Mesh du ResourceManager</a></li>
                    </ul>
                </li>
            </ul>
        </nav>

        <main>
            <!-- Introduction -->
            <section id="introduction">
                <h2>Introduction</h2>
                <p>
                    Galaxy3DEngine est un moteur de rendu 3D moderne construit en Rust avec une couche d'abstraction multi-API.
                    Supporte actuellement Vulkan, avec un support pr√©vu pour Direct3D 12.
                </p>
                <p>
                    L'API est con√ßue avec une s√©paration claire entre le rendu et la pr√©sentation, permettant :
                </p>
                <ul>
                    <li>Rendu vers texture (render-to-texture)</li>
                    <li>Rendu multi-passes</li>
                    <li>Effets de post-traitement</li>
                    <li>Deferred shading</li>
                </ul>
                <div class="note">
                    <strong>Note :</strong> Tous les objets de l'API sont bas√©s sur des traits et retourn√©s en tant que <code>Arc&lt;dyn Trait&gt;</code> pour l'abstraction du backend.
                </div>
            </section>

            <!-- galaxy_3d_engine::galaxy3d::Engine -->
            <section id="galaxy3dengine">
                <a href="#toc" class="back-to-toc">‚Üë Table des Mati√®res</a>
                <h2>galaxy_3d_engine::galaxy3d::Engine</h2>
                <p>Gestionnaire de singletons pour les sous-syst√®mes du moteur. Fournit un acc√®s global au renderer et g√®re le cycle de vie de tous les singletons du moteur.</p>

                <h3 id="galaxy3dengine-initialization">Initialisation</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-initialize')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::initialize()</span>
                        <span class="summary">Initialise le moteur (appeler une fois au d√©marrage)</span>
                    </h3>
                    <div id="galaxy3dengine-initialize" class="accordion-content">
                        <p>Initialise l'√©tat global du moteur. Doit √™tre appel√© une fois avant de cr√©er des sous-syst√®mes.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn initialize() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialiser le moteur
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // ... cr√©er le renderer et autres sous-syst√®mes ...

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-shutdown')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::shutdown()</span>
                        <span class="summary">Arr√™te le moteur et d√©truit tous les singletons</span>
                    </h3>
                    <div id="galaxy3dengine-shutdown" class="accordion-content">
                        <p>D√©truit tous les singletons du moteur et nettoie l'√©tat global. Appeler √† l'arr√™t de l'application.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn shutdown()</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() {
    galaxy_3d_engine::galaxy3d::Engine::initialize().unwrap();

    // ... code de l'application ...

    // Nettoyage
    galaxy_3d_engine::galaxy3d::Engine::shutdown();
}</code></pre>
                    </div>
                </div>

                <h3 id="galaxy3dengine-renderer-management">Gestion du Renderer</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-create-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::create_renderer()</span>
                        <span class="summary">Cr√©e et enregistre le singleton renderer</span>
                    </h3>
                    <div id="galaxy3dengine-create-renderer" class="accordion-content">
                        <p>
                            Cr√©e un singleton renderer √† partir de n'importe quel type impl√©mentant le trait Renderer.
                            Le renderer est automatiquement envelopp√© dans Arc&lt;Mutex&gt; pour un acc√®s thread-safe.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn create_renderer&lt;R: Renderer + 'static&gt;(renderer: R) -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Param√®tres</h4>
                        <ul>
                            <li><code>renderer</code> - N'importe quel type impl√©mentant le trait Renderer</li>
                        </ul>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Moteur non initialis√©</li>
                            <li>Renderer existe d√©j√†</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::{galaxy_3d_engine::galaxy3d::Engine, galaxy_3d_engine::galaxy3d::render::Config};
use galaxy_3d_engine_renderer_vulkan::galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // Cr√©er un renderer Vulkan
    let config = galaxy_3d_engine::galaxy3d::render::Config::default();
    let vulkan_renderer = galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new(&window, config)?;

    // Enregistrer comme singleton (API simplifi√©e)
    galaxy_3d_engine::galaxy3d::Engine::create_renderer(vulkan_renderer)?;

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::renderer()</span>
                        <span class="summary">Obtient le singleton renderer global</span>
                    </h3>
                    <div id="galaxy3dengine-renderer" class="accordion-content">
                        <p>Retourne un pointeur partag√© vers le singleton renderer. Le renderer est envelopp√© dans un Mutex pour un acc√®s mutable thread-safe.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn renderer() -> galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;Mutex&lt;dyn Renderer&gt;&gt;&gt;</code></pre>
                        <h4>Retour</h4>
                        <p>Un pointeur partag√© vers le renderer envelopp√© dans un Mutex</p>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Moteur non initialis√©</li>
                            <li>Renderer non cr√©√©</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::{galaxy_3d_engine::galaxy3d::Engine, BufferDesc, BufferUsage};

fn create_vertex_buffer() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Acc√®s au renderer global
    let renderer = galaxy_3d_engine::galaxy3d::Engine::renderer()?;
    let mut renderer_guard = renderer.lock().unwrap();

    // Cr√©er un buffer
    let buffer = renderer_guard.create_buffer(BufferDesc {
        size: 1024,
        usage: BufferUsage::Vertex,
    })?;

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-destroy-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::destroy_renderer()</span>
                        <span class="summary">D√©truit le singleton renderer</span>
                    </h3>
                    <div id="galaxy3dengine-destroy-renderer" class="accordion-content">
                        <p>
                            Supprime le singleton renderer du stockage global. Les r√©f√©rences existantes au renderer
                            (pointeurs Arc) resteront valides jusqu'√† ce qu'elles soient lib√©r√©es.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn destroy_renderer() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // ... utiliser le renderer ...

    // Nettoyage
    galaxy_3d_engine::galaxy3d::Engine::destroy_renderer()?;
    galaxy_3d_engine::galaxy3d::Engine::shutdown();

    Ok(())
}</code></pre>
                    </div>
                </div>

                <h3 id="galaxy3dengine-resource-manager">Resource Manager</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-create-resource-manager')">
                        <span>Engine::create_resource_manager()</span>
                        <span class="summary">Cr√©e le singleton resource manager</span>
                    </h3>
                    <div id="galaxy3dengine-create-resource-manager" class="accordion-content">
                        <p>
                            Cr√©e un nouveau ResourceManager et l'enregistre comme singleton global.
                            Le ResourceManager fournit un stockage centralis√© et un acc√®s aux ressources du moteur.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn create_resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Engine non initialis√©</li>
                            <li>ResourceManager d√©j√† existant</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;
    // Le ResourceManager est maintenant disponible globalement
    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-resource-manager')">
                        <span>Engine::resource_manager()</span>
                        <span class="summary">R√©cup√®re le singleton resource manager</span>
                    </h3>
                    <div id="galaxy3dengine-resource-manager" class="accordion-content">
                        <p>
                            Retourne un pointeur partag√© vers le ResourceManager envelopp√© dans un Mutex pour un acc√®s thread-safe.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;Mutex&lt;ResourceManager&gt;&gt;&gt;</code></pre>
                        <h4>Erreurs</h4>
                        <ul>
                            <li>Engine non initialis√©</li>
                            <li>ResourceManager non cr√©√©</li>
                        </ul>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;

    let rm = Engine::resource_manager()?;
    let rm_guard = rm.lock().unwrap();
    // Utiliser rm_guard...

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-destroy-resource-manager')">
                        <span>Engine::destroy_resource_manager()</span>
                        <span class="summary">D√©truit le singleton resource manager</span>
                    </h3>
                    <div id="galaxy3dengine-destroy-resource-manager" class="accordion-content">
                        <p>
                            Supprime le singleton resource manager du stockage global.
                            Doit √™tre appel√© avant de d√©truire le renderer, car les ressources peuvent r√©f√©rencer des objets GPU.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn destroy_resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Exemple</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;

    // ... utiliser les ressources ...

    // Nettoyage (resource manager avant renderer)
    Engine::destroy_resource_manager()?;
    Engine::destroy_renderer()?;
    Engine::shutdown();

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="note">
                    <strong>Thread Safety :</strong> Engine utilise OnceLock + RwLock pour une gestion thread-safe des singletons.
                    Plusieurs threads peuvent acc√©der au renderer et au resource manager en toute s√©curit√© simultan√©ment (avec verrouillage mutex interne).
                </div>
            </section>

            <!-- Renderer -->
            <section id="renderer">
                <a href="#toc" class="back-to-toc">‚Üë Table des Mati√®res</a>
                <h2>Renderer</h2>
                <p>L'interface factory principale pour cr√©er des ressources, command lists, swapchains, et soumettre du travail au GPU.</p>

                <h3 id="renderer-creation">Cr√©ation & Initialisation</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('renderer-new')">
                        <span>galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new()</span>
                        <span class="summary">Cr√©e une nouvelle instance de renderer Vulkan</span>
                    </h3>
                    <div id="renderer-new" class="accordion-content">
                        <p>
                            Cr√©e et initialise un nouveau renderer Vulkan. C'est le point d'entr√©e du moteur de rendu.
                            Configure l'instance Vulkan, le physical device, le logical device, et l'allocateur m√©moire.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>window: &Window</code> - Le handle de fen√™tre winit</li>
                            <li><code>config: galaxy_3d_engine::galaxy3d::render::Config</code> - Configuration du renderer (validation layers, etc.)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn Renderer&gt;&gt;</code></p>
                        <pre><code class="language-rust">use galaxy_3d_engine_renderer_vulkan::galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer;
use galaxy_3d_engine::{Renderer, galaxy_3d_engine::galaxy3d::render::Config};

let config = galaxy_3d_engine::galaxy3d::render::Config {
    enable_validation: true,
};

let renderer = galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new(&window, config)?;
</code></pre>
                    </div>
                </div>

                <h3 id="renderer-resources">Gestion des Ressources</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-buffer')">
                        <span>create_buffer()</span>
                        <span class="summary">Cr√©e un buffer GPU (vertex, index, uniform)</span>
                    </h3>
                    <div id="create-buffer" class="accordion-content">
                        <p>
                            Cr√©e un buffer GPU pour stocker des donn√©es de vertices, d'indices, ou d'uniformes.
                            Le buffer est allou√© avec gpu-allocator et peut √™tre mis √† jour apr√®s cr√©ation.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: BufferDesc</code> - Description du buffer (taille, usage, donn√©es)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;&gt;</code></p>
                        <pre><code class="language-rust">let vertex_data: Vec&lt;f32&gt; = vec![/* positions des vertices */];

let vertex_buffer = renderer.create_buffer(BufferDesc {
    size: (vertex_data.len() * std::mem::size_of::&lt;f32&gt;()) as u64,
    usage: BufferUsage::VERTEX,
    data: Some(bytemuck::cast_slice(&vertex_data)),
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-texture')">
                        <span>create_texture()</span>
                        <span class="summary">Cr√©e une texture GPU (2D ou array) avec donn√©es initiales optionnelles</span>
                    </h3>
                    <div id="create-texture" class="accordion-content">
                        <p>
                            Cr√©e une texture GPU (2D simple ou texture array) et upload optionnellement des donn√©es d'image initiales.
                            G√®re les transitions de layout et le staging buffer en interne.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: TextureDesc</code> - Description de la texture (largeur, hauteur, format, array_layers, donn√©es)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Texture&gt;&gt;</code></p>
                        <pre><code class="language-rust">// Texture 2D simple
let image_data: Vec&lt;u8&gt; = load_image("texture.png")?;

let texture = renderer.create_texture(TextureDesc {
    width: 512,
    height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    array_layers: 1,
    data: Some(TextureData::Single(image_data)),
})?;

// Texture array (4 couches)
let texture_array = renderer.create_texture(TextureDesc {
    width: 256,
    height: 256,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    array_layers: 4,
    data: Some(TextureData::Layers(vec![
        TextureLayerData { layer: 0, data: grass_data },
        TextureLayerData { layer: 1, data: dirt_data },
    ])),
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-shader')">
                        <span>create_shader()</span>
                        <span class="summary">Cr√©e un module shader depuis du bytecode SPIR-V</span>
                    </h3>
                    <div id="create-shader" class="accordion-content">
                        <p>
                            Cr√©e un module shader depuis du bytecode SPIR-V compil√©.
                            Supporte les stages vertex, fragment, compute, et autres.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: ShaderDesc</code> - Description du shader (stage, code SPIR-V)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Shader&gt;&gt;</code></p>
                        <pre><code class="language-rust">let vertex_spirv = include_bytes!("shaders/shader.vert.spv");

let vertex_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Vertex,
    code: vertex_spirv,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-pipeline')">
                        <span>create_pipeline()</span>
                        <span class="summary">Cr√©e un pipeline graphique avec shaders et √©tat</span>
                    </h3>
                    <div id="create-pipeline" class="accordion-content">
                        <p>
                            Cr√©e un pipeline graphique complet incluant shaders, layout de vertices,
                            topologie primitive, push constants, descriptor sets, et configuration de blending.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: PipelineDesc</code> - Description du pipeline</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;&gt;</code></p>
                        <pre><code class="language-rust">let pipeline = renderer.create_pipeline(PipelineDesc {
    vertex_shader: vertex_shader.clone(),
    fragment_shader: fragment_shader.clone(),
    vertex_layout: VertexLayout {
        bindings: vec![
            VertexBinding {
                binding: 0,
                stride: 20, // 3 floats (pos) + 2 floats (uv)
                input_rate: VertexInputRate::Vertex,
            },
        ],
        attributes: vec![
            VertexAttribute {
                location: 0,
                binding: 0,
                format: VertexFormat::Float3,
                offset: 0,
            },
            VertexAttribute {
                location: 1,
                binding: 0,
                format: VertexFormat::Float2,
                offset: 12,
            },
        ],
    },
    topology: PrimitiveTopology::TriangleList,
    push_constant_ranges: vec![],
    descriptor_set_layouts: vec![],
    enable_blending: false,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-descriptor-set')">
                        <span>create_descriptor_set_for_texture()</span>
                        <span class="summary">Cr√©e un descriptor set li√© √† une texture</span>
                    </h3>
                    <div id="create-descriptor-set" class="accordion-content">
                        <p>
                            Cr√©e un descriptor set avec un binding de sampler de texture.
                            Utilis√© pour lier des textures aux shaders.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>texture: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Texture&gt;</code> - La texture √† lier</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::DescriptorSet&gt;&gt;</code></p>
                        <pre><code class="language-rust">let texture = renderer.create_texture(texture_desc)?;
let descriptor_set = renderer.create_descriptor_set_for_texture(&texture)?;

// Plus tard, dans le rendu:
command_list.bind_descriptor_sets(&pipeline, &[&descriptor_set])?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-command-list')">
                        <span>create_command_list()</span>
                        <span class="summary">Cr√©e une command list r√©utilisable pour enregistrer des commandes GPU</span>
                    </h3>
                    <div id="create-command-list" class="accordion-content">
                        <p>
                            Cr√©e une command list (command buffer) pour enregistrer des commandes de rendu.
                            Les command lists peuvent √™tre r√©utilis√©es sur plusieurs frames.
                        </p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::CommandList&gt;&gt;</code></p>
                        <pre><code class="language-rust">let command_list = renderer.create_command_list()?;

// Les command lists peuvent √™tre r√©utilis√©es
let command_lists = [
    renderer.create_command_list()?,
    renderer.create_command_list()?,
];

let current_cmd = &command_lists[frame_index % 2];
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-swapchain')">
                        <span>create_swapchain()</span>
                        <span class="summary">Cr√©e une swapchain pour pr√©senter √† une fen√™tre</span>
                    </h3>
                    <div id="create-swapchain" class="accordion-content">
                        <p>
                            Cr√©e une swapchain attach√©e √† une fen√™tre pour pr√©senter les images rendues.
                            G√®re l'acquisition d'images et la pr√©sentation avec synchronisation appropri√©e.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>window: &Window</code> - La fen√™tre vers laquelle pr√©senter</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Swapchain&gt;&gt;</code></p>
                        <pre><code class="language-rust">let swapchain = renderer.create_swapchain(&window)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-render-pass')">
                        <span>create_render_pass()</span>
                        <span class="summary">Cr√©e une configuration de render pass</span>
                    </h3>
                    <div id="create-render-pass" class="accordion-content">
                        <p>
                            Cr√©e une configuration de render pass d√©finissant les attachments et d√©pendances de subpasses.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>desc: RenderPassDesc</code> - Description du render pass</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderPass&gt;&gt;</code></p>
                        <pre><code class="language-rust">let render_pass = renderer.create_render_pass(RenderPassDesc {
    color_attachments: vec![
        ColorAttachmentDesc {
            format: swapchain.format(),
            load_op: LoadOp::Clear,
            store_op: StoreOp::Store,
        },
    ],
    depth_attachment: None,
})?;
</code></pre>
                    </div>
                </div>

                <h3 id="renderer-submission">Soumission de Commandes</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('submit-with-sync')">
                        <span>submit_with_sync()</span>
                        <span class="summary">Soumet la command list avec synchronisation swapchain</span>
                    </h3>
                    <div id="submit-with-sync" class="accordion-content">
                        <p>
                            Soumet une command list √† la queue GPU avec synchronisation appropri√©e pour la pr√©sentation swapchain.
                            Attend le s√©maphore image disponible et signale le s√©maphore rendu termin√©.
                        </p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>command_list: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::CommandList&gt;</code> - La command list √† soumettre</li>
                            <li><code>sync_info: &SwapchainSyncInfo</code> - Info de synchronisation depuis la swapchain</li>
                            <li><code>image_index: u32</code> - Index de l'image swapchain</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">// Boucle de rendu typique
let (image_index, render_target) = swapchain.acquire_next_image()?;

command_list.begin()?;
command_list.begin_render_pass(&render_pass, &render_target, &clear_values)?;
// ... enregistrer les commandes de dessin ...
command_list.end_render_pass()?;
command_list.end()?;

let sync_info = swapchain.sync_info();
renderer.submit_with_sync(&command_list, &sync_info, image_index)?;

swapchain.present(image_index)?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Command List -->
            <section id="command-list">
                <h2>Command List</h2>
                <p>Voir <a href="#create-command-list">Renderer::create_command_list()</a> pour la cr√©ation de command list.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::CommandList</h3>
                <p>Interface pour enregistrer des commandes de rendu. Les command lists sont r√©utilisables et doivent √™tre d√©marr√©es/termin√©es √† chaque frame.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-begin')">
                        <span>begin()</span>
                        <span class="summary">D√©marre l'enregistrement de commandes</span>
                    </h3>
                    <div id="cmd-begin" class="accordion-content">
                        <p>D√©marre l'enregistrement de commandes dans la command list. Doit √™tre appel√© avant toute autre commande d'enregistrement.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.begin()?;
// ... enregistrer les commandes ...
command_list.end()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-begin-render-pass')">
                        <span>begin_render_pass()</span>
                        <span class="summary">D√©marre un render pass</span>
                    </h3>
                    <div id="cmd-begin-render-pass" class="accordion-content">
                        <p>D√©marre un render pass avec la render target et les valeurs de clear sp√©cifi√©es.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>render_pass: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderPass&gt;</code></li>
                            <li><code>render_target: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderTarget&gt;</code></li>
                            <li><code>clear_values: &[ClearValue]</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let clear_values = [
    ClearValue::Color([0.0, 0.0, 0.0, 1.0]), // Couleur de clear noir
];

command_list.begin_render_pass(&render_pass, &render_target, &clear_values)?;
// ... commandes de dessin ...
command_list.end_render_pass()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-pipeline')">
                        <span>bind_pipeline()</span>
                        <span class="summary">Lie un pipeline graphique</span>
                    </h3>
                    <div id="cmd-bind-pipeline" class="accordion-content">
                        <p>Lie un pipeline graphique pour les commandes de dessin suivantes.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>pipeline: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_pipeline(&pipeline)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-vertex-buffer')">
                        <span>bind_vertex_buffer()</span>
                        <span class="summary">Lie un buffer de vertices</span>
                    </h3>
                    <div id="cmd-bind-vertex-buffer" class="accordion-content">
                        <p>Lie un buffer de vertices √† un slot de binding.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>buffer: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;</code></li>
                            <li><code>binding: u32</code> - Slot de binding (g√©n√©ralement 0)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_vertex_buffer(&vertex_buffer, 0)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-index-buffer')">
                        <span>bind_index_buffer()</span>
                        <span class="summary">Lie un buffer d'indices</span>
                    </h3>
                    <div id="cmd-bind-index-buffer" class="accordion-content">
                        <p>Lie un buffer d'indices pour le dessin index√©.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>buffer: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;</code></li>
                            <li><code>offset: u64</code> - Offset en octets (g√©n√©ralement 0)</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_index_buffer(&index_buffer, 0)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-descriptor-sets')">
                        <span>bind_descriptor_sets()</span>
                        <span class="summary">Lie des descriptor sets (textures, uniforms)</span>
                    </h3>
                    <div id="cmd-bind-descriptor-sets" class="accordion-content">
                        <p>Lie des descriptor sets contenant des textures et uniform buffers.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>pipeline: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;</code></li>
                            <li><code>descriptor_sets: &[&Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::DescriptorSet&gt;]</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_descriptor_sets(&pipeline, &[&texture_descriptor])?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-push-constants')">
                        <span>push_constants()</span>
                        <span class="summary">Met √† jour les donn√©es de push constants</span>
                    </h3>
                    <div id="cmd-push-constants" class="accordion-content">
                        <p>Met √† jour les donn√©es de push constants pour des param√®tres rapides par draw (transforms, temps, etc.).</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>offset: u32</code> - Offset dans le bloc de push constants</li>
                            <li><code>data: &[u8]</code> - Octets bruts √† pousser</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let time: f32 = elapsed_time;
command_list.push_constants(0, &time.to_le_bytes())?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-draw')">
                        <span>draw()</span>
                        <span class="summary">√âmet un draw call</span>
                    </h3>
                    <div id="cmd-draw" class="accordion-content">
                        <p>Dessine des vertices non-index√©s.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>vertex_count: u32</code></li>
                            <li><code>first_vertex: u32</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.draw(3, 0)?; // Dessine 3 vertices (1 triangle)
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-draw-indexed')">
                        <span>draw_indexed()</span>
                        <span class="summary">√âmet un draw call index√©</span>
                    </h3>
                    <div id="cmd-draw-indexed" class="accordion-content">
                        <p>Dessine de la g√©om√©trie index√©e.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>index_count: u32</code></li>
                            <li><code>first_index: u32</code></li>
                            <li><code>vertex_offset: i32</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.draw_indexed(6, 0, 0)?; // Dessine 6 indices (2 triangles)
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-set-viewport')">
                        <span>set_viewport()</span>
                        <span class="summary">D√©finit le viewport</span>
                    </h3>
                    <div id="cmd-set-viewport" class="accordion-content">
                        <p>D√©finit le viewport pour le rendu.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>viewport: Viewport</code></li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.set_viewport(Viewport {
    x: 0.0,
    y: 0.0,
    width: 800.0,
    height: 600.0,
    min_depth: 0.0,
    max_depth: 1.0,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-end-render-pass')">
                        <span>end_render_pass()</span>
                        <span class="summary">Termine le render pass actuel</span>
                    </h3>
                    <div id="cmd-end-render-pass" class="accordion-content">
                        <p>Termine le render pass actuellement actif.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.end_render_pass()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-end')">
                        <span>end()</span>
                        <span class="summary">Termine l'enregistrement de commandes</span>
                    </h3>
                    <div id="cmd-end" class="accordion-content">
                        <p>Termine l'enregistrement et finalise la command list pour soumission.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.end()?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Swapchain -->
            <section id="swapchain">
                <h2>Swapchain</h2>
                <p>Voir <a href="#create-swapchain">Renderer::create_swapchain()</a> pour la cr√©ation de swapchain.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Swapchain</h3>
                <p>G√®re la pr√©sentation √† une fen√™tre avec acquisition et pr√©sentation d'images synchronis√©es.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-acquire')">
                        <span>acquire_next_image()</span>
                        <span class="summary">Acquiert la prochaine image swapchain pour le rendu</span>
                    </h3>
                    <div id="swap-acquire" class="accordion-content">
                        <p>Acquiert la prochaine image disponible de la swapchain. Retourne l'index d'image et une render target.</p>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;(u32, Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderTarget&gt;)&gt;</code></p>
                        <pre><code class="language-rust">let (image_index, render_target) = swapchain.acquire_next_image()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-present')">
                        <span>present()</span>
                        <span class="summary">Pr√©sente l'image rendue √† l'√©cran</span>
                    </h3>
                    <div id="swap-present" class="accordion-content">
                        <p>Pr√©sente l'image √† l'index sp√©cifi√© √† l'√©cran apr√®s que le rendu soit termin√©.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>image_index: u32</code> - L'index d'image depuis acquire_next_image</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">swapchain.present(image_index)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-sync-info')">
                        <span>sync_info()</span>
                        <span class="summary">Obtient les informations de synchronisation pour la soumission</span>
                    </h3>
                    <div id="swap-sync-info" class="accordion-content">
                        <p>Retourne les informations de synchronisation n√©cessaires pour submit_with_sync().</p>
                        <p><strong>Retourne :</strong> <code>SwapchainSyncInfo</code></p>
                        <pre><code class="language-rust">let sync_info = swapchain.sync_info();
renderer.submit_with_sync(&command_list, &sync_info, image_index)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-format')">
                        <span>format()</span>
                        <span class="summary">Obtient le format d'image de la swapchain</span>
                    </h3>
                    <div id="swap-format" class="accordion-content">
                        <p>Retourne le format pixel des images swapchain.</p>
                        <p><strong>Retourne :</strong> <code>TextureFormat</code></p>
                        <pre><code class="language-rust">let format = swapchain.format();
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Render Target -->
            <section id="render-target">
                <h2>Render Target</h2>
                <p>Repr√©sente une destination de rendu (soit image swapchain soit texture).</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::RenderTarget</h3>
                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::RenderTarget est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de render target. Les render targets sont typiquement obtenus depuis swapchain.acquire_next_image() ou cr√©√©s depuis des textures.
                </div>
            </section>

            <!-- Render Pass -->
            <section id="render-pass">
                <h2>Render Pass</h2>
                <p>Voir <a href="#create-render-pass">Renderer::create_render_pass()</a> pour la cr√©ation de render pass.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::RenderPass</h3>
                <p>D√©finit la configuration de rendu incluant les attachments couleur/profondeur et les op√©rations load/store.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::RenderPass est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de render pass.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('renderpass-desc')">
                        <span>RenderPassDesc</span>
                        <span class="summary">Structure de description du render pass</span>
                    </h3>
                    <div id="renderpass-desc" class="accordion-content">
                        <p>D√©crit une configuration de render pass.</p>
                        <pre><code class="language-rust">let render_pass = renderer.create_render_pass(RenderPassDesc {
    color_attachments: vec![
        ColorAttachmentDesc {
            format: swapchain.format(),
            load_op: LoadOp::Clear,   // Clear au chargement
            store_op: StoreOp::Store, // Stocker le r√©sultat
        },
    ],
    depth_attachment: None,
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Pipeline -->
            <section id="pipeline">
                <h2>Pipeline</h2>
                <p>Voir <a href="#create-pipeline">Renderer::create_pipeline()</a> pour la cr√©ation de pipeline.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Pipeline</h3>
                <p>√âtat du pipeline graphique incluant shaders, layout de vertices, topologie, et blending.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::Pipeline est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de pipeline.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('pipeline-desc')">
                        <span>PipelineDesc</span>
                        <span class="summary">Structure de description du pipeline</span>
                    </h3>
                    <div id="pipeline-desc" class="accordion-content">
                        <p>Configuration compl√®te du pipeline incluant :</p>
                        <ul>
                            <li>Shaders vertex et fragment</li>
                            <li>Layout de vertices (bindings et attributs)</li>
                            <li>Topologie primitive</li>
                            <li>Ranges de push constants</li>
                            <li>Layouts de descriptor sets</li>
                            <li>Configuration de blending</li>
                        </ul>
                        <pre><code class="language-rust">let pipeline = renderer.create_pipeline(PipelineDesc {
    vertex_shader: vertex_shader.clone(),
    fragment_shader: fragment_shader.clone(),
    vertex_layout: VertexLayout {
        bindings: vec![
            VertexBinding {
                binding: 0,
                stride: 20,
                input_rate: VertexInputRate::Vertex,
            },
        ],
        attributes: vec![
            VertexAttribute {
                location: 0,
                binding: 0,
                format: VertexFormat::Float3,
                offset: 0,
            },
        ],
    },
    topology: PrimitiveTopology::TriangleList,
    push_constant_ranges: vec![
        PushConstantRange {
            stages: vec![ShaderStage::Vertex],
            offset: 0,
            size: 16, // 4 floats
        },
    ],
    descriptor_set_layouts: vec![],
    enable_blending: true, // Activer alpha blending
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Buffer -->
            <section id="buffer">
                <h2>Buffer</h2>
                <p>Voir <a href="#create-buffer">Renderer::create_buffer()</a> pour la cr√©ation de buffer.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Buffer</h3>
                <p>Buffer GPU pour stocker des donn√©es de vertices, d'indices, ou d'uniformes.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('buffer-update')">
                        <span>update()</span>
                        <span class="summary">Met √† jour les donn√©es du buffer</span>
                    </h3>
                    <div id="buffer-update" class="accordion-content">
                        <p>Met √† jour le contenu du buffer avec de nouvelles donn√©es.</p>
                        <p><strong>Param√®tres :</strong></p>
                        <ul>
                            <li><code>offset: u64</code> - Offset en octets</li>
                            <li><code>data: &[u8]</code> - Nouvelles donn√©es</li>
                        </ul>
                        <p><strong>Retourne :</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let new_vertex_data: Vec&lt;f32&gt; = vec![/* vertices mis √† jour */];
vertex_buffer.update(0, bytemuck::cast_slice(&new_vertex_data))?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Texture -->
            <section id="texture">
                <h2>Texture</h2>
                <p>Voir <a href="#create-texture">Renderer::create_texture()</a> pour la cr√©ation de texture.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Texture</h3>
                <p>Texture GPU pour le sampling dans les shaders. Supporte les textures 2D simples et les texture arrays.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-info')">
                        <span>info()</span>
                        <span class="summary">Obtenir les propri√©t√©s en lecture seule de la texture</span>
                    </h3>
                    <div id="texture-info" class="accordion-content">
                        <p>Retourne une r√©f√©rence vers les propri√©t√©s en lecture seule de la texture.</p>
                        <p><strong>Retourne :</strong> <code>&amp;TextureInfo</code></p>
                        <pre><code class="language-rust">let texture = renderer.create_texture(desc)?;
let info = texture.info();
println!("Taille : {}x{}, couches : {}", info.width, info.height, info.array_layers);
println!("Est array : {}", info.is_array());
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-info-struct')">
                        <span>TextureInfo</span>
                        <span class="summary">Propri√©t√©s de texture en lecture seule</span>
                    </h3>
                    <div id="texture-info-struct" class="accordion-content">
                        <pre><code class="language-rust">pub struct TextureInfo {
    pub width: u32,
    pub height: u32,
    pub format: TextureFormat,
    pub usage: TextureUsage,
    pub array_layers: u32,
}

impl TextureInfo {
    pub fn is_array(&amp;self) -&gt; bool { self.array_layers &gt; 1 }
}
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-desc')">
                        <span>TextureDesc</span>
                        <span class="summary">Descripteur de cr√©ation de texture</span>
                    </h3>
                    <div id="texture-desc" class="accordion-content">
                        <pre><code class="language-rust">pub struct TextureDesc {
    pub width: u32,
    pub height: u32,
    pub format: TextureFormat,
    pub usage: TextureUsage,
    pub array_layers: u32,           // 1 = 2D simple, &gt;1 = texture array
    pub data: Option&lt;TextureData&gt;,   // Donn√©es initiales optionnelles
}
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-data')">
                        <span>TextureData</span>
                        <span class="summary">Donn√©es initiales de texture pour upload</span>
                    </h3>
                    <div id="texture-data" class="accordion-content">
                        <pre><code class="language-rust">pub enum TextureData {
    /// Donn√©es d'image unique (pour textures simples, ou couche 0 d'un array)
    Single(Vec&lt;u8&gt;),

    /// Donn√©es par couche pour texture arrays.
    /// Seules les couches list√©es sont upload√©es ; les autres restent non initialis√©es.
    Layers(Vec&lt;TextureLayerData&gt;),
}

pub struct TextureLayerData {
    pub layer: u32,      // Index de couche cible (0-based)
    pub data: Vec&lt;u8&gt;,   // Octets de pixels bruts pour cette couche
}
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-formats')">
                        <span>TextureFormat</span>
                        <span class="summary">Formats de texture support√©s</span>
                    </h3>
                    <div id="texture-formats" class="accordion-content">
                        <p>Formats de texture courants :</p>
                        <ul>
                            <li><code>R8G8B8A8_SRGB</code> - RGBA 8-bit avec espace couleur sRGB</li>
                            <li><code>R8G8B8A8_UNORM</code> - RGBA 8-bit lin√©aire</li>
                            <li><code>B8G8R8A8_SRGB</code> - BGRA 8-bit avec sRGB (courant pour swapchains)</li>
                        </ul>
                        <pre><code class="language-rust">let texture = renderer.create_texture(TextureDesc {
    width: 512,
    height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    array_layers: 1,
    data: Some(TextureData::Single(image_data)),
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Shader -->
            <section id="shader">
                <h2>Shader</h2>
                <p>Voir <a href="#create-shader">Renderer::create_shader()</a> pour la cr√©ation de shader.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::Shader</h3>
                <p>Module shader compil√© (bytecode SPIR-V).</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::Shader est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de shader.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('shader-stages')">
                        <span>ShaderStage</span>
                        <span class="summary">Types de stages de shader</span>
                    </h3>
                    <div id="shader-stages" class="accordion-content">
                        <p>Stages de shader support√©s :</p>
                        <ul>
                            <li><code>ShaderStage::Vertex</code> - Shader vertex</li>
                            <li><code>ShaderStage::Fragment</code> - Shader fragment/pixel</li>
                            <li><code>ShaderStage::Compute</code> - Shader compute (futur)</li>
                        </ul>
                        <pre><code class="language-rust">let vertex_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Vertex,
    code: include_bytes!("shader.vert.spv"),
})?;

let fragment_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Fragment,
    code: include_bytes!("shader.frag.spv"),
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Descriptor Set -->
            <section id="descriptor-set">
                <h2>Descriptor Set</h2>
                <p>Voir <a href="#create-descriptor-set">Renderer::create_descriptor_set_for_texture()</a> pour la cr√©ation de descriptor set.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::render::DescriptorSet</h3>
                <p>Lie des ressources (textures, uniform buffers) aux shaders.</p>

                <div class="note">
                    <strong>Note :</strong> galaxy_3d_engine::galaxy3d::render::DescriptorSet est un trait marqueur sans m√©thodes publiques. Il est utilis√© pour la s√©curit√© de type afin d'√©viter l'utilisation incorrecte accidentelle des handles de descriptor set. Actuellement, les descriptor sets sont cr√©√©s sp√©cifiquement pour les textures en utilisant <code>create_descriptor_set_for_texture()</code>. Les versions futures supporteront des layouts de descripteurs personnalis√©s.
                </div>

                <pre><code class="language-rust">// Cr√©er texture et descriptor set
let texture = renderer.create_texture(texture_desc)?;
let descriptor_set = renderer.create_descriptor_set_for_texture(&texture)?;

// Utiliser dans le rendu
command_list.bind_descriptor_sets(&pipeline, &[&descriptor_set])?;
</code></pre>
            </section>

            <!-- Logger -->
            <section id="logger">
                <h2>Logger</h2>
                <p>Voir <a href="#set-logger">Engine::set_logger()</a> pour l'installation du logger.</p>

                <h3>Trait galaxy_3d_engine::galaxy3d::log::Logger</h3>
                <p>Interface de logger personnalis√© pour intercepter et router les logs internes du moteur.</p>

                <div class="note">
                    <strong>Note :</strong> Le trait Logger permet aux utilisateurs d'impl√©menter des backends de logging personnalis√©s (par ex. tracing, slog, log4rs) pour capturer les logs internes du Galaxy3D Engine. Le moteur utilise ce logger pour tous ses messages internes via des macros internes (non expos√©es dans l'API publique).
                </div>

                <h4>D√©finition du Trait</h4>
                <pre><code class="language-rust">pub trait Logger: Send + Sync {
    fn log(&self, entry: &LogEntry);
}

pub struct LogEntry&lt;'a&gt; {
    pub severity: LogSeverity,
    pub source: &'a str,       // ex: "galaxy3d::vulkan::Renderer"
    pub message: &'a str,
    pub file: Option&lt;&'a str&gt;, // Chemin du fichier (seulement pour les erreurs)
    pub line: Option&lt;u32&gt;,     // Num√©ro de ligne (seulement pour les erreurs)
}

pub enum LogSeverity {
    Trace,   // Informations de d√©bogage verbeux
    Debug,   // Informations de d√©bogage d√©taill√©es
    Info,    // Messages informatifs
    Warn,    // Messages d'avertissement
    Error,   // Messages d'erreur
}</code></pre>

                <h4>Exemple : Impl√©mentation TracingLogger</h4>
                <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::log::{Logger, LogEntry, LogSeverity};
use tracing::Level;

pub struct TracingLogger {
    // ... champs ...
}

impl Logger for TracingLogger {
    fn log(&self, entry: &LogEntry) {
        // Convertir LogSeverity vers tracing::Level
        let level = match entry.severity {
            LogSeverity::Trace => Level::TRACE,
            LogSeverity::Debug => Level::DEBUG,
            LogSeverity::Info => Level::INFO,
            LogSeverity::Warn => Level::WARN,
            LogSeverity::Error => Level::ERROR,
        };

        // Formater le message avec le module source
        let full_message = if let (Some(file), Some(line)) = (entry.file, entry.line) {
            format!("[{}] {} ({}:{})", entry.source, entry.message, file, line)
        } else {
            format!("[{}] {}", entry.source, entry.message)
        };

        // Router vers tracing
        match level {
            Level::TRACE => tracing::trace!("{}", full_message),
            Level::DEBUG => tracing::debug!("{}", full_message),
            Level::INFO => tracing::info!("{}", full_message),
            Level::WARN => tracing::warn!("{}", full_message),
            Level::ERROR => tracing::error!("{}", full_message),
        }
    }
}

// Installer le logger personnalis√©
fn main() {
    galaxy3d::Engine::initialize()?;

    let logger = TracingLogger::new("app.log")?;
    galaxy3d::Engine::set_logger(logger);

    // Tous les logs du moteur seront maintenant rout√©s vers votre logger
}</code></pre>

                <h4>DefaultLogger</h4>
                <p>Si aucun logger personnalis√© n'est install√©, le moteur utilise <code>DefaultLogger</code> qui affiche sur la console avec couleurs et horodatage :</p>
                <pre><code class="language-bash">[2026-01-31 17:18:30.120] [INFO ] [galaxy3d::vulkan::Renderer] Vulkan renderer initialized
[2026-01-31 17:18:30.234] [ERROR] [galaxy3d::vulkan::Swapchain] Failed to acquire image (vulkan_swapchain.rs:142)</code></pre>

                <div class="note">
                    <strong>Important :</strong> Les macros de logging internes du moteur (<code>engine_trace!</code>, <code>engine_debug!</code>, <code>engine_info!</code>, <code>engine_warn!</code>, <code>engine_error!</code>) sont cach√©es de l'API publique (<code>#[doc(hidden)]</code>) et ne doivent PAS √™tre utilis√©es par les applications. Les applications doivent impl√©menter le trait Logger pour capturer les logs du moteur.
                </div>
            </section>

            <!-- Textures Ressource -->
            <section id="resource-texture">
                <a href="#toc" class="back-to-toc">‚Üë Table des Mati√®res</a>
                <h2>Textures Ressource</h2>
                <p>Types de textures au niveau ressource qui encapsulent les objets <code>render::Texture</code> (GPU) bas niveau avec des m√©tadonn√©es suppl√©mentaires. Architecture √† 3 niveaux :</p>
                <ul>
                    <li><strong>render::Texture</strong> ‚Äî Handle GPU (bas niveau, sp√©cifique au backend)</li>
                    <li><strong>resource::Texture</strong> ‚Äî Ressource nomm√©e avec sous-r√©gions (ce module)</li>
                    <li><strong>scene::Texture</strong> ‚Äî Objet de sc√®ne (futur)</li>
                </ul>

                <h3 id="resource-texture-trait">Trait Texture</h3>
                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-texture-trait-detail')">
                        resource::Texture
                        <span class="summary">Trait d'acc√®s uniforme √† toute texture ressource</span>
                    </h3>
                    <div id="resource-texture-trait-detail" class="accordion-content">
                        <p>Fournit un acc√®s uniforme √† toute texture ressource quel que soit son type concret (simple, atlas ou array). Utilise des trait objects (<code>dyn Texture</code>) pour le dispatch dynamique ‚Äî similaire √† l'h√©ritage virtuel C++.</p>
                        <pre><code>pub trait Texture: Send + Sync {
    fn render_texture(&amp;self) -&gt; &amp;Arc&lt;dyn render::Texture&gt;;
    fn descriptor_set(&amp;self) -&gt; &amp;Arc&lt;dyn DescriptorSet&gt;;
    fn region_names(&amp;self) -&gt; Vec&lt;&amp;str&gt;;

    // M√©thodes de downcast (retournent None pour le mauvais type)
    fn as_simple(&amp;self) -&gt; Option&lt;&amp;SimpleTexture&gt;;
    fn as_atlas(&amp;self) -&gt; Option&lt;&amp;AtlasTexture&gt;;
    fn as_atlas_mut(&amp;mut self) -&gt; Option&lt;&amp;mut AtlasTexture&gt;;
    fn as_array(&amp;self) -&gt; Option&lt;&amp;ArrayTexture&gt;;
    fn as_array_mut(&amp;mut self) -&gt; Option&lt;&amp;mut ArrayTexture&gt;;
}</code></pre>
                    </div>
                </div>

                <h3 id="resource-texture-types">Types Concrets</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-simple-texture')">
                        SimpleTexture
                        <span class="summary">Texture simple sans sous-r√©gions</span>
                    </h3>
                    <div id="resource-simple-texture" class="accordion-content">
                        <p>Le type le plus simple ‚Äî encapsule une texture GPU et son descriptor set sans m√©tadonn√©es suppl√©mentaires. Une texture = une image, mapping 1:1.</p>
                        <pre><code>// Cr√©ation via ResourceManager
let rm = Engine::resource_manager()?;
let mut rm_guard = rm.lock().unwrap();
rm_guard.create_simple_texture("skybox".into(), TextureDesc {
    width: 512, height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    data: Some(image_data),
})?;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-atlas-texture')">
                        AtlasTexture
                        <span class="summary">Atlas de textures avec r√©gions UV nomm√©es</span>
                    </h3>
                    <div id="resource-atlas-texture" class="accordion-content">
                        <p>Encapsule une texture GPU contenant plusieurs sous-images arrang√©es spatialement. Chaque sous-image est identifi√©e par un nom et d√©crite par des coordonn√©es UV (<code>AtlasRegion</code>).</p>
                        <p>Les r√©gions peuvent √™tre fournies √† la cr√©ation et/ou ajout√©es plus tard :</p>
                        <pre><code>// Cr√©er avec des r√©gions
rm_guard.create_atlas_texture("tileset".into(), desc, &amp;[
    AtlasRegionDesc { name: "grass".into(), region: AtlasRegion { u: 0.0, v: 0.0, width: 0.25, height: 0.25 } },
])?;

// Ou cr√©er vide et ajouter plus tard
rm_guard.create_atlas_texture("sprites".into(), desc, &amp;[])?;
rm_guard.add_atlas_region("sprites", "player".into(),
    AtlasRegion { u: 0.0, v: 0.0, width: 0.5, height: 0.5 })?;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-array-texture')">
                        ArrayTexture
                        <span class="summary">Tableau de textures avec couches nomm√©es</span>
                    </h3>
                    <div id="resource-array-texture" class="accordion-content">
                        <p>Encapsule un tableau de textures GPU o√π chaque couche est identifi√©e par un nom et mapp√©e √† un index.</p>
                        <pre><code>// Structure ArrayLayerDesc
pub struct ArrayLayerDesc {
    pub name: String,
    pub layer: u32,
    pub data: Option&lt;Vec&lt;u8&gt;&gt;,  // Donn√©es pixels optionnelles
}

// Cr√©er avec des couches
rm_guard.create_array_texture("terrain".into(), desc, &amp;[
    ArrayLayerDesc { name: "grass".into(), layer: 0, data: Some(grass_pixels) },
    ArrayLayerDesc { name: "dirt".into(), layer: 1, data: Some(dirt_pixels) },
])?;

// Ou cr√©er vide et ajouter plus tard
rm_guard.create_array_texture("materials".into(), desc, &amp;[])?;
rm_guard.add_array_layer("materials", "wood".into(), 0, Some(&amp;wood_pixels))?;</code></pre>
                    </div>
                </div>

                <h3 id="resource-texture-manager">API Texture du ResourceManager</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-simple')">
                        ResourceManager::create_simple_texture()
                        <span class="summary">Cr√©er et enregistrer une texture simple</span>
                    </h3>
                    <div id="rm-create-simple" class="accordion-content">
                        <p><strong>Validation :</strong> <code>desc.array_layers</code> doit √™tre 1.</p>
                        <pre><code>pub fn create_simple_texture(&amp;mut self, name: String, desc: TextureDesc) -&gt; Result&lt;Arc&lt;dyn Texture&gt;&gt;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-atlas')">
                        ResourceManager::create_atlas_texture()
                        <span class="summary">Cr√©er et enregistrer une texture atlas</span>
                    </h3>
                    <div id="rm-create-atlas" class="accordion-content">
                        <p><strong>Validation :</strong> <code>desc.array_layers</code> doit √™tre 1 (atlas utilise des r√©gions UV, pas des couches array).</p>
                        <pre><code>pub fn create_atlas_texture(&amp;mut self, name: String, desc: TextureDesc, regions: &amp;[AtlasRegionDesc]) -&gt; Result&lt;Arc&lt;dyn Texture&gt;&gt;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-array')">
                        ResourceManager::create_array_texture()
                        <span class="summary">Cr√©er et enregistrer une texture array</span>
                    </h3>
                    <div id="rm-create-array" class="accordion-content">
                        <p><strong>Validation :</strong> <code>desc.array_layers</code> doit √™tre &gt; 1. Les indices de couche dans <code>layers</code> doivent √™tre &lt; <code>desc.array_layers</code>.</p>
                        <pre><code>pub fn create_array_texture(&amp;mut self, name: String, desc: TextureDesc, layers: &amp;[ArrayLayerDesc]) -&gt; Result&lt;Arc&lt;dyn Texture&gt;&gt;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-get-texture')">
                        ResourceManager::texture() / remove_texture() / texture_count()
                        <span class="summary">Acc√©der et g√©rer les textures enregistr√©es</span>
                    </h3>
                    <div id="rm-get-texture" class="accordion-content">
                        <pre><code>pub fn texture(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Arc&lt;dyn Texture&gt;&gt;
pub fn remove_texture(&amp;mut self, name: &amp;str) -&gt; bool
pub fn texture_count(&amp;self) -&gt; usize</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-add-region-layer')">
                        ResourceManager::add_atlas_region() / add_array_layer()
                        <span class="summary">Ajouter des r√©gions/couches apr√®s la cr√©ation</span>
                    </h3>
                    <div id="rm-add-region-layer" class="accordion-content">
                        <p>Utilise <code>Arc::get_mut</code> pour un acc√®s mutable s√ªr. √âchoue si d'autres r√©f√©rences √† l'Arc existent.</p>
                        <pre><code>pub fn add_atlas_region(&amp;mut self, texture_name: &amp;str, region_name: String, region: AtlasRegion) -&gt; Result&lt;()&gt;
pub fn add_array_layer(&amp;mut self, texture_name: &amp;str, layer_name: String, layer: u32, data: Option&lt;&amp;[u8]&gt;) -&gt; Result&lt;()&gt;</code></pre>
                    </div>
                </div>
            </section>

            <!-- Meshes Ressource -->
            <section id="resource-mesh">
                <a href="#toc" class="back-to-toc">‚Üë Table des Mati√®res</a>
                <h2>Meshes Ressource</h2>
                <p>Types de meshes au niveau ressource qui encapsulent les buffers GPU bas niveau avec une hi√©rarchie structur√©e √† 4 niveaux. Partie du syst√®me de gestion des ressources :</p>
                <ul>
                    <li><strong>render::Buffer</strong> ‚Äî Buffers GPU (bas niveau, sp√©cifique au backend)</li>
                    <li><strong>resource::Mesh</strong> ‚Äî Ressource nomm√©e avec entr√©es, LODs et submeshes (ce module)</li>
                    <li><strong>scene::Mesh</strong> ‚Äî Objet de sc√®ne (futur)</li>
                </ul>

                <h3 id="resource-mesh-hierarchy">Hi√©rarchie √† 4 Niveaux</h3>
                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-hierarchy-detail')">
                        Vue d'Ensemble de la Hi√©rarchie
                        <span class="summary">Mesh ‚Üí MeshEntry ‚Üí MeshLOD ‚Üí SubMesh</span>
                    </h3>
                    <div id="resource-mesh-hierarchy-detail" class="accordion-content">
                        <p>Le syst√®me de mesh utilise une hi√©rarchie √† 4 niveaux con√ßue pour les mod√®les 3D complexes avec plusieurs parties, niveaux de LOD et mat√©riaux. Utilise le <strong>pattern Vec+HashMap</strong> pour un acc√®s O(1) par id (index) et par nom :</p>
                        <pre><code>Mesh (ressource groupe)
‚îú‚îÄ‚îÄ name: "characters"
‚îú‚îÄ‚îÄ vertex_buffer: Arc&lt;dyn Buffer&gt;       // Partag√© par tous
‚îú‚îÄ‚îÄ index_buffer: Option&lt;Arc&lt;dyn Buffer&gt;&gt; // Partag√© par tous (optionnel)
‚îú‚îÄ‚îÄ vertex_layout: VertexLayout           // Partag√© par tous
‚îú‚îÄ‚îÄ index_type: IndexType                 // U16 ou U32
‚îú‚îÄ‚îÄ total_vertex_count: u32
‚îú‚îÄ‚îÄ total_index_count: u32
‚îÇ
‚îú‚îÄ‚îÄ mesh_entries: Vec&lt;MeshEntry&gt;          // Stockage par id (index)
‚îî‚îÄ‚îÄ entry_names: HashMap&lt;String, usize&gt;   // Mapping nom ‚Üí id
    ‚îú‚îÄ‚îÄ "hero" ‚Üí 0
    ‚îÇ   ‚îî‚îÄ‚îÄ lods: Vec&lt;MeshLOD&gt;
    ‚îÇ       ‚îú‚îÄ‚îÄ [0] LOD 0 (haute d√©finition)
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ submeshes: Vec&lt;SubMesh&gt;
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ submesh_names: HashMap&lt;String, usize&gt;
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ "body" ‚Üí 0
    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ "armor" ‚Üí 1
    ‚îÇ       ‚îî‚îÄ‚îÄ [1] LOD 1 (basse d√©finition)
    ‚îî‚îÄ‚îÄ "enemy" ‚Üí 1
        ‚îî‚îÄ‚îÄ ...</code></pre>
                        <p><strong>Principes de Conception :</strong></p>
                        <ul>
                            <li><strong>Pattern Vec+HashMap :</strong> <code>Vec&lt;T&gt;</code> pour le stockage + <code>HashMap&lt;String, usize&gt;</code> pour la recherche par nom</li>
                            <li><strong>Acc√®s par ID :</strong> Les m√©thodes retournent des IDs (<code>usize</code>) pour un acc√®s rapide ult√©rieur</li>
                            <li>Paire de buffers unique par Mesh : Toutes les entr√©es partagent les buffers vertex/index (efficace GPU)</li>
                            <li>Entr√©e de donn√©es brutes : MeshDesc prend des <code>Vec&lt;u8&gt;</code>, ResourceManager cr√©e les buffers GPU</li>
                            <li>Validation automatique : Offsets des submeshes valid√©s par rapport aux tailles des buffers</li>
                            <li>Calcul automatique des counts : Counts vertex/index calcul√©s depuis la longueur des donn√©es et le stride</li>
                        </ul>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-struct')">
                        Mesh
                        <span class="summary">Ressource groupe mesh de niveau sup√©rieur</span>
                    </h3>
                    <div id="resource-mesh-struct" class="accordion-content">
                        <p>La ressource mesh de niveau sup√©rieur contenant les buffers GPU partag√©s et les entr√©es nomm√©es. Utilise le pattern Vec+HashMap pour un acc√®s O(1) par id ou par nom.</p>
                        <pre><code>pub struct Mesh {
    name: String,
    vertex_buffer: Arc&lt;dyn render::Buffer&gt;,
    index_buffer: Option&lt;Arc&lt;dyn render::Buffer&gt;&gt;,
    vertex_layout: VertexLayout,
    index_type: IndexType,
    total_vertex_count: u32,
    total_index_count: u32,
    mesh_entries: Vec&lt;MeshEntry&gt;,           // Stockage par id (index)
    entry_names: HashMap&lt;String, usize&gt;,    // Mapping nom ‚Üí id
}

impl Mesh {
    pub fn name(&amp;self) -&gt; &amp;str;
    pub fn vertex_buffer(&amp;self) -&gt; &amp;Arc&lt;dyn render::Buffer&gt;;
    pub fn index_buffer(&amp;self) -&gt; Option&lt;&amp;Arc&lt;dyn render::Buffer&gt;&gt;;
    pub fn is_indexed(&amp;self) -&gt; bool;
    pub fn vertex_layout(&amp;self) -&gt; &amp;VertexLayout;
    pub fn index_type(&amp;self) -&gt; IndexType;
    pub fn total_vertex_count(&amp;self) -&gt; u32;
    pub fn total_index_count(&amp;self) -&gt; u32;

    // Acc√®s par id (le plus rapide - index direct)
    pub fn mesh_entry(&amp;self, id: usize) -&gt; Option&lt;&amp;MeshEntry&gt;;
    // Obtenir l'id depuis le nom (pour acc√®s rapide ult√©rieur)
    pub fn mesh_entry_id(&amp;self, name: &amp;str) -&gt; Option&lt;usize&gt;;
    // Acc√®s par nom (convenience - lookup HashMap puis index)
    pub fn mesh_entry_by_name(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;MeshEntry&gt;;
    pub fn mesh_entry_names(&amp;self) -&gt; Vec&lt;&amp;str&gt;;
    pub fn mesh_entry_count(&amp;self) -&gt; usize;

    // Acc√®s direct au submesh par ids (le plus rapide)
    pub fn submesh(&amp;self, entry_id: usize, lod: usize, submesh_id: usize) -&gt; Option&lt;&amp;SubMesh&gt;;
    // Acc√®s direct au submesh par noms (convenience)
    pub fn submesh_by_name(&amp;self, entry_name: &amp;str, lod: usize, submesh_name: &amp;str) -&gt; Option&lt;&amp;SubMesh&gt;;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-entry')">
                        MeshEntry
                        <span class="summary">Mesh nomm√© dans un groupe (ex: "hero", "enemy")</span>
                    </h3>
                    <div id="resource-mesh-entry" class="accordion-content">
                        <p>Un mesh nomm√© dans un groupe, contenant des niveaux de LOD. Le nom de l'entr√©e est la cl√© dans le HashMap du Mesh parent.</p>
                        <pre><code>pub struct MeshEntry {
    lods: Vec&lt;MeshLOD&gt;,  // Index 0 = plus d√©taill√©
}

impl MeshEntry {
    pub fn lod(&amp;self, index: usize) -&gt; Option&lt;&amp;MeshLOD&gt;;
    pub fn lod_count(&amp;self) -&gt; usize;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-lod')">
                        MeshLOD
                        <span class="summary">Niveau de d√©tail contenant des submeshes nomm√©s</span>
                    </h3>
                    <div id="resource-mesh-lod" class="accordion-content">
                        <p>Un niveau de d√©tail contenant des submeshes nomm√©s (groupes de mat√©riaux). LOD 0 est le plus d√©taill√©. Utilise le pattern Vec+HashMap pour un acc√®s O(1) par id ou par nom.</p>
                        <pre><code>pub struct MeshLOD {
    submeshes: Vec&lt;SubMesh&gt;,                // Stockage par id (index)
    submesh_names: HashMap&lt;String, usize&gt;,  // Mapping nom ‚Üí id
}

impl MeshLOD {
    // Acc√®s par id (le plus rapide - index direct)
    pub fn submesh(&amp;self, id: usize) -&gt; Option&lt;&amp;SubMesh&gt;;
    // Obtenir l'id depuis le nom (pour acc√®s rapide ult√©rieur)
    pub fn submesh_id(&amp;self, name: &amp;str) -&gt; Option&lt;usize&gt;;
    // Acc√®s par nom (convenience - lookup HashMap puis index)
    pub fn submesh_by_name(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;SubMesh&gt;;
    pub fn submesh_names(&amp;self) -&gt; Vec&lt;&amp;str&gt;;
    pub fn submesh_count(&amp;self) -&gt; usize;
    pub fn submeshes(&amp;self) -&gt; impl Iterator&lt;Item = (&amp;str, &amp;SubMesh)&gt;;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-submesh')">
                        SubMesh
                        <span class="summary">R√©gion dessinable avec offsets de buffer</span>
                    </h3>
                    <div id="resource-mesh-submesh" class="accordion-content">
                        <p>Une r√©gion dessinable dans les buffers partag√©s. Contient tous les param√®tres pour un draw call. Les champs index sont ignor√©s si le Mesh parent n'est pas index√©.</p>
                        <pre><code>pub struct SubMesh {
    vertex_offset: u32,
    vertex_count: u32,
    index_offset: u32,   // Ignor√© si mesh non-index√©
    index_count: u32,    // Ignor√© si mesh non-index√©
    topology: PrimitiveTopology,
}

impl SubMesh {
    pub fn vertex_offset(&amp;self) -&gt; u32;
    pub fn vertex_count(&amp;self) -&gt; u32;
    pub fn index_offset(&amp;self) -&gt; u32;
    pub fn index_count(&amp;self) -&gt; u32;
    pub fn topology(&amp;self) -&gt; PrimitiveTopology;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-index-type')">
                        IndexType
                        <span class="summary">Type d'√©l√©ment du buffer d'indices</span>
                    </h3>
                    <div id="resource-mesh-index-type" class="accordion-content">
                        <p>Sp√©cifie le type d'√©l√©ment pour les buffers d'indices.</p>
                        <pre><code>pub enum IndexType {
    U16,  // Indices 16-bit (max 65535 vertices)
    U32,  // Indices 32-bit (max ~4 milliards de vertices)
}

impl IndexType {
    pub fn size_bytes(&amp;self) -&gt; u32;  // Retourne 2 pour U16, 4 pour U32
}</code></pre>
                    </div>
                </div>

                <h3 id="resource-mesh-descriptors">Structures de Descripteurs</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-desc')">
                        MeshDesc
                        <span class="summary">Descripteur de cr√©ation de mesh avec donn√©es brutes</span>
                    </h3>
                    <div id="resource-mesh-desc" class="accordion-content">
                        <p>D√©crit un mesh pour sa cr√©ation. Utilise des donn√©es d'octets bruts ‚Äî le ResourceManager cr√©e les buffers GPU en interne.</p>
                        <pre><code>pub struct MeshDesc {
    pub renderer: Arc&lt;Mutex&lt;dyn Renderer&gt;&gt;, // Renderer pour la cr√©ation des buffers GPU
    pub vertex_data: Vec&lt;u8&gt;,           // Donn√©es vertex brutes entrelac√©es
    pub index_data: Option&lt;Vec&lt;u8&gt;&gt;,    // Donn√©es d'indices brutes (None si non-index√©)
    pub vertex_layout: VertexLayout,     // D√©finit le stride pour le count de vertex
    pub index_type: IndexType,           // U16 ou U32
    pub meshes: Vec&lt;MeshEntryDesc&gt;,      // Entr√©es initiales (peut √™tre vide)
}</code></pre>
                        <p><strong>Validation :</strong></p>
                        <ul>
                            <li><code>vertex_data.len()</code> doit √™tre divisible par <code>vertex_layout.stride()</code></li>
                            <li>Si <code>index_data</code> est fourni, sa longueur doit √™tre divisible par <code>index_type.size_bytes()</code></li>
                        </ul>
                        <p><strong>Exemple :</strong></p>
                        <pre><code>let desc = MeshDesc {
    renderer: renderer.clone(),
    vertex_data: vertex_bytes,
    index_data: Some(index_bytes),
    vertex_layout: VertexLayout {
        bindings: vec![VertexBinding { binding: 0, stride: 20, input_rate: VertexInputRate::Vertex }],
        attributes: vec![
            VertexAttribute { location: 0, binding: 0, format: VertexFormat::Float3, offset: 0 },
            VertexAttribute { location: 1, binding: 0, format: VertexFormat::Float2, offset: 12 },
        ],
    },
    index_type: IndexType::U16,
    meshes: vec![
        MeshEntryDesc {
            name: "hero".into(),
            lods: vec![
                MeshLODDesc {
                    lod_index: 0,
                    submeshes: vec![
                        SubMeshDesc {
                            name: "body".into(),
                            vertex_offset: 0,
                            vertex_count: 5000,
                            index_offset: 0,
                            index_count: 15000,
                            topology: PrimitiveTopology::TriangleList,
                        },
                    ],
                },
            ],
        },
    ],
};</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-entry-desc')">
                        MeshEntryDesc / MeshLODDesc / SubMeshDesc
                        <span class="summary">Descripteurs Entry, LOD et SubMesh</span>
                    </h3>
                    <div id="resource-mesh-entry-desc" class="accordion-content">
                        <pre><code>pub struct MeshEntryDesc {
    pub name: String,              // Nom de l'entr√©e (cl√© dans le HashMap meshes)
    pub lods: Vec&lt;MeshLODDesc&gt;,
}

pub struct MeshLODDesc {
    pub lod_index: usize,          // Niveau LOD (0 = plus d√©taill√©)
    pub submeshes: Vec&lt;SubMeshDesc&gt;,
}

pub struct SubMeshDesc {
    pub name: String,              // Nom du SubMesh (cl√© dans le HashMap submeshes)
    pub vertex_offset: u32,
    pub vertex_count: u32,
    pub index_offset: u32,         // Ignor√© si mesh non-index√©
    pub index_count: u32,          // Ignor√© si mesh non-index√©
    pub topology: PrimitiveTopology,
}</code></pre>
                    </div>
                </div>

                <h3 id="resource-mesh-manager">API Mesh du ResourceManager</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-mesh')">
                        ResourceManager::create_mesh()
                        <span class="summary">Cr√©er et enregistrer une ressource mesh</span>
                    </h3>
                    <div id="rm-create-mesh" class="accordion-content">
                        <p>Cr√©e les buffers GPU √† partir des donn√©es brutes et enregistre la ressource mesh. Retourne le mesh cr√©√© pour utilisation imm√©diate.</p>
                        <pre><code>pub fn create_mesh(&amp;mut self, name: String, desc: MeshDesc) -&gt; Result&lt;Arc&lt;Mesh&gt;&gt;</code></pre>
                        <p><strong>Validation :</strong></p>
                        <ul>
                            <li>La taille des donn√©es vertex doit √™tre divisible par le stride</li>
                            <li>La taille des donn√©es index (si pr√©sentes) doit √™tre divisible par la taille de l'√©l√©ment d'index</li>
                            <li>Les plages SubMesh doivent √™tre dans les limites des buffers</li>
                        </ul>
                        <p><strong>Exemple :</strong></p>
                        <pre><code>let rm = Engine::resource_manager()?;
let mut rm_guard = rm.lock().unwrap();
let renderer = Engine::renderer()?;

let mesh = rm_guard.create_mesh("characters".into(), MeshDesc {
    renderer: renderer.clone(),
    vertex_data: vertex_bytes,
    index_data: Some(index_bytes),
    vertex_layout,
    index_type: IndexType::U16,
    meshes: vec![
        MeshEntryDesc {
            name: "hero".into(),
            lods: vec![
                MeshLODDesc {
                    lod_index: 0,
                    submeshes: vec![
                        SubMeshDesc {
                            name: "body".into(),
                            vertex_offset: 0,
                            vertex_count: 5000,
                            index_offset: 0,
                            index_count: 15000,
                            topology: PrimitiveTopology::TriangleList,
                        },
                    ],
                },
            ],
        },
    ],
})?;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-mesh-access')">
                        ResourceManager::mesh() / remove_mesh() / mesh_count()
                        <span class="summary">Acc√©der et g√©rer les meshes enregistr√©s</span>
                    </h3>
                    <div id="rm-mesh-access" class="accordion-content">
                        <pre><code>pub fn mesh(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Arc&lt;Mesh&gt;&gt;
pub fn remove_mesh(&amp;mut self, name: &amp;str) -&gt; bool
pub fn mesh_count(&amp;self) -&gt; usize</code></pre>
                        <p><strong>Exemple :</strong></p>
                        <pre><code>// Acc√©der √† un mesh
if let Some(mesh) = rm_guard.mesh("characters") {
    let vb = mesh.vertex_buffer();
    let ib = mesh.index_buffer();

    // Obtenir l'id de l'entr√©e pour un acc√®s rapide (√©vite les lookups HashMap r√©p√©t√©s)
    let hero_id = mesh.mesh_entry_id("hero").unwrap();

    // Acc√®s par id (le plus rapide) via mesh_entry() -&gt; lod() -&gt; submesh()
    if let Some(hero) = mesh.mesh_entry(hero_id) {
        if let Some(lod0) = hero.lod(0) {
            // Obtenir l'id du submesh pour le rendu
            let body_id = lod0.submesh_id("body").unwrap();
            let body = lod0.submesh(body_id).unwrap();
            // Dessiner le submesh...

            // Ou it√©rer sur tous les submeshes
            for (name, submesh) in lod0.submeshes() {
                println!("Dessin du submesh: {}", name);
            }
        }
    }

    // Acc√®s direct par ids (le plus rapide)
    let body_id = mesh.mesh_entry(hero_id).unwrap().lod(0).unwrap().submesh_id("body").unwrap();
    if let Some(submesh) = mesh.submesh(hero_id, 0, body_id) {
        // Acc√®s direct par ids
    }

    // Ou par noms (convenience)
    if let Some(submesh) = mesh.submesh_by_name("hero", 0, "body") {
        // Acc√®s direct par noms
    }
}

// Supprimer un mesh
rm_guard.remove_mesh("old_model");</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-add-mesh-parts')">
                        ResourceManager::add_mesh_entry() / add_mesh_lod() / add_submesh()
                        <span class="summary">Ajouter des entries, LODs et submeshes apr√®s cr√©ation (retourne des ids)</span>
                    </h3>
                    <div id="rm-add-mesh-parts" class="accordion-content">
                        <p>Ajouter des √©l√©ments de hi√©rarchie √† des meshes existants apr√®s leur cr√©ation. Utilise <code>Arc::get_mut</code> pour un acc√®s mutable s√ªr. <strong>Les m√©thodes retournent des ids</strong> pour un acc√®s rapide ult√©rieur.</p>
                        <pre><code>// Retourne l'id (index) de l'entr√©e nouvellement cr√©√©e
pub fn add_mesh_entry(&amp;mut self, mesh_name: &amp;str, desc: MeshEntryDesc) -&gt; Result&lt;usize&gt;

// Prend entry_id (pas le nom) et retourne le lod_index
pub fn add_mesh_lod(&amp;mut self, mesh_name: &amp;str, entry_id: usize, desc: MeshLODDesc) -&gt; Result&lt;usize&gt;

// Prend entry_id (pas le nom) et retourne le submesh_id
pub fn add_submesh(&amp;mut self, mesh_name: &amp;str, entry_id: usize, lod_index: usize, desc: SubMeshDesc) -&gt; Result&lt;usize&gt;</code></pre>
                        <p><strong>Exemple :</strong></p>
                        <pre><code>// Ajouter une nouvelle entr√©e - retourne son id pour acc√®s rapide
let enemy_id: usize = rm_guard.add_mesh_entry("characters", MeshEntryDesc {
    name: "enemy".into(),
    lods: vec![MeshLODDesc { lod_index: 0, submeshes: vec![...] }],
})?;

// Ajouter un nouveau niveau de LOD √† une entr√©e existante (utiliser entry_id, pas le nom)
let hero_id = mesh.mesh_entry_id("hero").unwrap();
let lod1_idx: usize = rm_guard.add_mesh_lod("characters", hero_id, MeshLODDesc {
    lod_index: 1,  // LOD 1 (moins d√©taill√©)
    submeshes: vec![SubMeshDesc {
        name: "body_lod1".into(),
        vertex_offset: 5000, vertex_count: 2000,
        index_offset: 15000, index_count: 6000,
        topology: PrimitiveTopology::TriangleList,
    }],
})?;

// Ajouter un submesh √† un LOD existant (utiliser entry_id)
let cape_id: usize = rm_guard.add_submesh("characters", hero_id, 0, SubMeshDesc {
    name: "cape".into(),
    vertex_offset: 7000,
    vertex_count: 500,
    index_offset: 21000,
    index_count: 1500,
    topology: PrimitiveTopology::TriangleList,
})?;

// Acc√®s rapide avec les ids stock√©s
let cape = mesh.submesh(hero_id, 0, cape_id).unwrap();</code></pre>
                    </div>
                </div>

                <div class="note">
                    <strong>Rendu avec les Meshes :</strong> Utilisez <code>mesh.vertex_buffer()</code> et <code>mesh.index_buffer()</code> pour obtenir les buffers GPU √† lier. SubMesh fournit les offsets et counts pour les draw calls. Utilisez <code>mesh.is_indexed()</code> pour choisir entre <code>draw()</code> et <code>draw_indexed()</code>.
                </div>
            </section>
        </main>
    </div>

    <footer>
        <p>&copy; 2026 Galaxy3DEngine - Moteur de Rendu 3D Multi-API en Rust</p>
        <p>Documentation G√©n√©r√©e</p>
    </footer>

    <script>
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            const header = content.previousElementSibling;

            // Fermer tous les autres accord√©ons
            document.querySelectorAll('.accordion-content').forEach(el => {
                if (el.id !== id) {
                    el.classList.remove('active');
                    el.previousElementSibling.classList.remove('active');
                }
            });

            // Toggle accord√©on actuel
            content.classList.toggle('active');
            header.classList.toggle('active');
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const toggle = event.target;

            section.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
    </script>
</body>
</html>
