<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy3DEngine - API Documentation</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --code-bg: #2c3e50;
            --code-color: #ecf0f1;
            --border-color: #bdc3c7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-color);
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
        }

        nav {
            position: sticky;
            top: 2rem;
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        nav h2 {
            font-size: 1.3rem;
            margin-bottom: 1rem;
            color: var(--secondary-color);
        }

        nav ul {
            list-style: none;
        }

        nav ul li {
            margin-bottom: 0.5rem;
        }

        nav ul ul {
            margin-left: 1rem;
            margin-top: 0.5rem;
            display: none;
        }

        nav ul ul.expanded {
            display: block;
        }

        nav a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.3s;
        }

        nav a:hover {
            color: var(--secondary-color);
        }

        .toc-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
        }

        .toc-toggle::before {
            content: 'â–¸';
            display: inline-block;
            margin-right: 0.5rem;
            transition: transform 0.3s;
        }

        .toc-toggle.expanded::before {
            content: 'â–¼';
        }

        main {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        section {
            margin-bottom: 3rem;
        }

        section h2 {
            font-size: 2rem;
            color: var(--secondary-color);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        section h3 {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin: 1.5rem 0 0.5rem 0;
        }

        .api-item {
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .api-item h3 {
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            padding: 1rem;
            margin: 0;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .api-item h3:hover {
            background: linear-gradient(to right, #e9ecef, #dee2e6);
        }

        .api-item h3::after {
            content: 'â–¼';
            font-size: 0.8rem;
            transition: transform 0.3s;
        }

        .api-item h3.active::after {
            transform: rotate(-180deg);
        }

        .summary {
            font-weight: normal;
            color: #6c757d;
            font-size: 0.9rem;
            margin-left: 1rem;
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 1rem;
        }

        .accordion-content.active {
            max-height: 2000px;
            padding: 1rem;
        }

        .accordion-content p {
            margin-bottom: 1rem;
        }

        pre {
            background: var(--code-bg);
            color: var(--code-color);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
        }

        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .warning {
            background: #f8d7da;
            border-left: 4px solid var(--accent-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>ðŸŒŒ Galaxy3DEngine</h1>
        <p>Multi-API 3D Rendering Engine in Rust - API Documentation</p>
    </header>

    <div class="container">
        <nav id="toc">
            <h2>ðŸ“‘ Table of Contents</h2>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('galaxy3dengine-section')">galaxy_3d_engine::galaxy3d::Engine</span>
                    <ul id="galaxy3dengine-section">
                        <li><a href="#galaxy3dengine-initialization">Initialization</a></li>
                        <li><a href="#galaxy3dengine-renderer-management">Renderer Management</a></li>
                        <li><a href="#galaxy3dengine-resource-manager">Resource Manager</a></li>
                    </ul>
                </li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('renderer-section')">Renderer</span>
                    <ul id="renderer-section">
                        <li><a href="#renderer-creation">Creation</a></li>
                        <li><a href="#renderer-resources">Resources</a></li>
                        <li><a href="#renderer-submission">Submission</a></li>
                    </ul>
                </li>
                <li><a href="#command-list">Command List</a></li>
                <li><a href="#swapchain">Swapchain</a></li>
                <li><a href="#render-target">Render Target</a></li>
                <li><a href="#render-pass">Render Pass</a></li>
                <li><a href="#pipeline">Pipeline</a></li>
                <li><a href="#buffer">Buffer</a></li>
                <li><a href="#texture">Texture</a></li>
                <li><a href="#shader">Shader</a></li>
                <li><a href="#descriptor-set">Descriptor Set</a></li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('resource-texture-section')">Resource Textures</span>
                    <ul id="resource-texture-section">
                        <li><a href="#resource-texture-trait">Texture Trait</a></li>
                        <li><a href="#resource-texture-types">Concrete Types</a></li>
                        <li><a href="#resource-texture-manager">ResourceManager Texture API</a></li>
                    </ul>
                </li>
                <li>
                    <span class="toc-toggle" onclick="toggleSection('resource-mesh-section')">Resource Meshes</span>
                    <ul id="resource-mesh-section">
                        <li><a href="#resource-mesh-hierarchy">4-Level Hierarchy</a></li>
                        <li><a href="#resource-mesh-descriptors">Descriptor Structures</a></li>
                        <li><a href="#resource-mesh-manager">ResourceManager Mesh API</a></li>
                    </ul>
                </li>
            </ul>
        </nav>

        <main>
            <!-- Introduction -->
            <section id="introduction">
                <h2>Introduction</h2>
                <p>
                    Galaxy3DEngine is a modern 3D rendering engine built in Rust with a multi-API abstraction layer.
                    Currently supports Vulkan, with planned support for Direct3D 12.
                </p>
                <p>
                    The API is designed with a clear separation between rendering and presentation, enabling:
                </p>
                <ul>
                    <li>Render-to-texture capabilities</li>
                    <li>Multi-pass rendering</li>
                    <li>Post-processing effects</li>
                    <li>Deferred shading</li>
                </ul>
                <div class="note">
                    <strong>Note:</strong> All API objects are trait-based and returned as <code>Arc&lt;dyn Trait&gt;</code> for backend abstraction.
                </div>
            </section>

            <!-- galaxy_3d_engine::galaxy3d::Engine -->
            <section id="galaxy3dengine">
                <a href="#toc" class="back-to-toc">â†‘ Table of Contents</a>
                <h2>galaxy_3d_engine::galaxy3d::Engine</h2>
                <p>Singleton manager for engine subsystems. Provides global access to the renderer and manages the lifecycle of all engine singletons.</p>

                <h3 id="galaxy3dengine-initialization">Initialization</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-initialize')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::initialize()</span>
                        <span class="summary">Initialize the engine (call once at startup)</span>
                    </h3>
                    <div id="galaxy3dengine-initialize" class="accordion-content">
                        <p>Initializes the global engine state. Must be called once before creating any subsystems.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn initialize() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize engine
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // ... create renderer and other subsystems ...

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-shutdown')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::shutdown()</span>
                        <span class="summary">Shutdown the engine and destroy all singletons</span>
                    </h3>
                    <div id="galaxy3dengine-shutdown" class="accordion-content">
                        <p>Destroys all engine singletons and cleans up global state. Call at application shutdown.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn shutdown()</code></pre>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() {
    galaxy_3d_engine::galaxy3d::Engine::initialize().unwrap();

    // ... application code ...

    // Cleanup
    galaxy_3d_engine::galaxy3d::Engine::shutdown();
}</code></pre>
                    </div>
                </div>

                <h3 id="galaxy3dengine-renderer-management">Renderer Management</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-create-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::create_renderer()</span>
                        <span class="summary">Create and register the renderer singleton</span>
                    </h3>
                    <div id="galaxy3dengine-create-renderer" class="accordion-content">
                        <p>
                            Creates a renderer singleton from any type implementing the Renderer trait.
                            The renderer is automatically wrapped in Arc&lt;Mutex&gt; for thread-safe access.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn create_renderer&lt;R: Renderer + 'static&gt;(renderer: R) -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Parameters</h4>
                        <ul>
                            <li><code>renderer</code> - Any type implementing the Renderer trait</li>
                        </ul>
                        <h4>Errors</h4>
                        <ul>
                            <li>Engine not initialized</li>
                            <li>Renderer already exists</li>
                        </ul>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::{galaxy_3d_engine::galaxy3d::Engine, galaxy_3d_engine::galaxy3d::render::Config};
use galaxy_3d_engine_renderer_vulkan::galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // Create Vulkan renderer
    let config = galaxy_3d_engine::galaxy3d::render::Config::default();
    let vulkan_renderer = galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new(&window, config)?;

    // Register as singleton (simplified API)
    galaxy_3d_engine::galaxy3d::Engine::create_renderer(vulkan_renderer)?;

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::renderer()</span>
                        <span class="summary">Get the global renderer singleton</span>
                    </h3>
                    <div id="galaxy3dengine-renderer" class="accordion-content">
                        <p>Returns a shared pointer to the renderer singleton. The renderer is wrapped in a Mutex for thread-safe mutable access.</p>
                        <h4>Signature</h4>
                        <pre><code>pub fn renderer() -> galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;Mutex&lt;dyn Renderer&gt;&gt;&gt;</code></pre>
                        <h4>Returns</h4>
                        <p>A shared pointer to the renderer wrapped in a Mutex</p>
                        <h4>Errors</h4>
                        <ul>
                            <li>Engine not initialized</li>
                            <li>Renderer not created</li>
                        </ul>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::{galaxy_3d_engine::galaxy3d::Engine, BufferDesc, BufferUsage};

fn create_vertex_buffer() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Access global renderer
    let renderer = galaxy_3d_engine::galaxy3d::Engine::renderer()?;
    let mut renderer_guard = renderer.lock().unwrap();

    // Create buffer
    let buffer = renderer_guard.create_buffer(BufferDesc {
        size: 1024,
        usage: BufferUsage::Vertex,
    })?;

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-destroy-renderer')">
                        <span>galaxy_3d_engine::galaxy3d::Engine::destroy_renderer()</span>
                        <span class="summary">Destroy the renderer singleton</span>
                    </h3>
                    <div id="galaxy3dengine-destroy-renderer" class="accordion-content">
                        <p>
                            Removes the renderer singleton from global storage. Existing renderer references
                            (Arc pointers) will remain valid until dropped.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn destroy_renderer() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    galaxy_3d_engine::galaxy3d::Engine::initialize()?;

    // ... use renderer ...

    // Cleanup
    galaxy_3d_engine::galaxy3d::Engine::destroy_renderer()?;
    galaxy_3d_engine::galaxy3d::Engine::shutdown();

    Ok(())
}</code></pre>
                    </div>
                </div>

                <h3 id="galaxy3dengine-resource-manager">Resource Manager</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-create-resource-manager')">
                        <span>Engine::create_resource_manager()</span>
                        <span class="summary">Create the resource manager singleton</span>
                    </h3>
                    <div id="galaxy3dengine-create-resource-manager" class="accordion-content">
                        <p>
                            Creates a new ResourceManager and registers it as a global singleton.
                            The ResourceManager provides centralized storage and access to engine resources.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn create_resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Errors</h4>
                        <ul>
                            <li>Engine not initialized</li>
                            <li>ResourceManager already exists</li>
                        </ul>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;
    // ResourceManager is now available globally
    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-resource-manager')">
                        <span>Engine::resource_manager()</span>
                        <span class="summary">Get the resource manager singleton</span>
                    </h3>
                    <div id="galaxy3dengine-resource-manager" class="accordion-content">
                        <p>
                            Returns a shared pointer to the ResourceManager wrapped in a Mutex for thread-safe access.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;Mutex&lt;ResourceManager&gt;&gt;&gt;</code></pre>
                        <h4>Errors</h4>
                        <ul>
                            <li>Engine not initialized</li>
                            <li>ResourceManager not created</li>
                        </ul>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;

    let rm = Engine::resource_manager()?;
    let rm_guard = rm.lock().unwrap();
    // Use rm_guard...

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('galaxy3dengine-destroy-resource-manager')">
                        <span>Engine::destroy_resource_manager()</span>
                        <span class="summary">Destroy the resource manager singleton</span>
                    </h3>
                    <div id="galaxy3dengine-destroy-resource-manager" class="accordion-content">
                        <p>
                            Removes the resource manager singleton from global storage.
                            Should be called before destroying the renderer, as resources may reference GPU objects.
                        </p>
                        <h4>Signature</h4>
                        <pre><code>pub fn destroy_resource_manager() -> galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></pre>
                        <h4>Example</h4>
                        <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::Engine;

fn main() -> Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Engine::initialize()?;
    Engine::create_resource_manager()?;

    // ... use resources ...

    // Cleanup (resource manager before renderer)
    Engine::destroy_resource_manager()?;
    Engine::destroy_renderer()?;
    Engine::shutdown();

    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="note">
                    <strong>Thread Safety:</strong> Engine uses OnceLock + RwLock for thread-safe singleton management.
                    Multiple threads can safely access the renderer and resource manager simultaneously (with internal mutex locking).
                </div>
            </section>

            <!-- Renderer -->
            <section id="renderer">
                <a href="#toc" class="back-to-toc">â†‘ Table of Contents</a>
                <h2>Renderer</h2>
                <p>The main factory interface for creating resources, command lists, swapchains, and submitting work to the GPU.</p>

                <h3 id="renderer-creation">Creation & Initialization</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('renderer-new')">
                        <span>galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new()</span>
                        <span class="summary">Creates a new Vulkan renderer instance</span>
                    </h3>
                    <div id="renderer-new" class="accordion-content">
                        <p>
                            Creates and initializes a new Vulkan renderer. This is the entry point for the rendering engine.
                            It sets up the Vulkan instance, physical device, logical device, and memory allocator.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>window: &Window</code> - The winit window handle</li>
                            <li><code>config: galaxy_3d_engine::galaxy3d::render::Config</code> - Renderer configuration (validation layers, etc.)</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn Renderer&gt;&gt;</code></p>
                        <pre><code class="language-rust">use galaxy_3d_engine_renderer_vulkan::galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer;
use galaxy_3d_engine::{Renderer, galaxy_3d_engine::galaxy3d::render::Config};

let config = galaxy_3d_engine::galaxy3d::render::Config {
    enable_validation: true,
};

let renderer = galaxy_3d_engine_renderer_vulkan::galaxy3d::VulkanRenderer::new(&window, config)?;
</code></pre>
                    </div>
                </div>

                <h3 id="renderer-resources">Resource Management</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-buffer')">
                        <span>create_buffer()</span>
                        <span class="summary">Creates a GPU buffer (vertex, index, uniform)</span>
                    </h3>
                    <div id="create-buffer" class="accordion-content">
                        <p>
                            Creates a GPU buffer for storing vertex data, index data, or uniform data.
                            The buffer is allocated using gpu-allocator and can be updated after creation.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>desc: BufferDesc</code> - Buffer description (size, usage, data)</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;&gt;</code></p>
                        <pre><code class="language-rust">let vertex_data: Vec&lt;f32&gt; = vec![/* vertex positions */];

let vertex_buffer = renderer.create_buffer(BufferDesc {
    size: (vertex_data.len() * std::mem::size_of::&lt;f32&gt;()) as u64,
    usage: BufferUsage::VERTEX,
    data: Some(bytemuck::cast_slice(&vertex_data)),
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-texture')">
                        <span>create_texture()</span>
                        <span class="summary">Creates a GPU texture (2D or array) with optional initial data</span>
                    </h3>
                    <div id="create-texture" class="accordion-content">
                        <p>
                            Creates a GPU texture (simple 2D or texture array) and optionally uploads initial image data.
                            Handles layout transitions and staging buffer management internally.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>desc: TextureDesc</code> - Texture description (width, height, format, array_layers, data)</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Texture&gt;&gt;</code></p>
                        <pre><code class="language-rust">// Simple 2D texture
let image_data: Vec&lt;u8&gt; = load_image("texture.png")?;

let texture = renderer.create_texture(TextureDesc {
    width: 512,
    height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    array_layers: 1,
    data: Some(TextureData::Single(image_data)),
})?;

// Texture array (4 layers)
let texture_array = renderer.create_texture(TextureDesc {
    width: 256,
    height: 256,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    array_layers: 4,
    data: Some(TextureData::Layers(vec![
        TextureLayerData { layer: 0, data: grass_data },
        TextureLayerData { layer: 1, data: dirt_data },
    ])),
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-shader')">
                        <span>create_shader()</span>
                        <span class="summary">Creates a shader module from SPIR-V bytecode</span>
                    </h3>
                    <div id="create-shader" class="accordion-content">
                        <p>
                            Creates a shader module from compiled SPIR-V bytecode.
                            Supports vertex, fragment, compute, and other shader stages.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>desc: ShaderDesc</code> - Shader description (stage, SPIR-V code)</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Shader&gt;&gt;</code></p>
                        <pre><code class="language-rust">let vertex_spirv = include_bytes!("shaders/shader.vert.spv");

let vertex_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Vertex,
    code: vertex_spirv,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-pipeline')">
                        <span>create_pipeline()</span>
                        <span class="summary">Creates a graphics pipeline with shaders and state</span>
                    </h3>
                    <div id="create-pipeline" class="accordion-content">
                        <p>
                            Creates a complete graphics pipeline including shaders, vertex layout,
                            primitive topology, push constants, descriptor sets, and blending configuration.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>desc: PipelineDesc</code> - Pipeline description</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;&gt;</code></p>
                        <pre><code class="language-rust">let pipeline = renderer.create_pipeline(PipelineDesc {
    vertex_shader: vertex_shader.clone(),
    fragment_shader: fragment_shader.clone(),
    vertex_layout: VertexLayout {
        bindings: vec![
            VertexBinding {
                binding: 0,
                stride: 20, // 3 floats (pos) + 2 floats (uv)
                input_rate: VertexInputRate::Vertex,
            },
        ],
        attributes: vec![
            VertexAttribute {
                location: 0,
                binding: 0,
                format: VertexFormat::Float3,
                offset: 0,
            },
            VertexAttribute {
                location: 1,
                binding: 0,
                format: VertexFormat::Float2,
                offset: 12,
            },
        ],
    },
    topology: PrimitiveTopology::TriangleList,
    push_constant_ranges: vec![],
    descriptor_set_layouts: vec![],
    enable_blending: false,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-descriptor-set')">
                        <span>create_descriptor_set_for_texture()</span>
                        <span class="summary">Creates a descriptor set bound to a texture</span>
                    </h3>
                    <div id="create-descriptor-set" class="accordion-content">
                        <p>
                            Creates a descriptor set with a texture sampler binding.
                            This is used to bind textures to shaders.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>texture: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Texture&gt;</code> - The texture to bind</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::DescriptorSet&gt;&gt;</code></p>
                        <pre><code class="language-rust">let texture = renderer.create_texture(texture_desc)?;
let descriptor_set = renderer.create_descriptor_set_for_texture(&texture)?;

// Later, in rendering:
command_list.bind_descriptor_sets(&pipeline, &[&descriptor_set])?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-command-list')">
                        <span>create_command_list()</span>
                        <span class="summary">Creates a reusable command list for recording GPU commands</span>
                    </h3>
                    <div id="create-command-list" class="accordion-content">
                        <p>
                            Creates a command list (command buffer) for recording rendering commands.
                            Command lists can be reused across multiple frames.
                        </p>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::CommandList&gt;&gt;</code></p>
                        <pre><code class="language-rust">let command_list = renderer.create_command_list()?;

// Command lists can be reused
let command_lists = [
    renderer.create_command_list()?,
    renderer.create_command_list()?,
];

let current_cmd = &command_lists[frame_index % 2];
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-swapchain')">
                        <span>create_swapchain()</span>
                        <span class="summary">Creates a swapchain for presenting to a window</span>
                    </h3>
                    <div id="create-swapchain" class="accordion-content">
                        <p>
                            Creates a swapchain attached to a window for presenting rendered images.
                            Manages image acquisition and presentation with proper synchronization.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>window: &Window</code> - The window to present to</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Swapchain&gt;&gt;</code></p>
                        <pre><code class="language-rust">let swapchain = renderer.create_swapchain(&window)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('create-render-pass')">
                        <span>create_render_pass()</span>
                        <span class="summary">Creates a render pass configuration</span>
                    </h3>
                    <div id="create-render-pass" class="accordion-content">
                        <p>
                            Creates a render pass configuration defining attachments and subpass dependencies.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>desc: RenderPassDesc</code> - Render pass description</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderPass&gt;&gt;</code></p>
                        <pre><code class="language-rust">let render_pass = renderer.create_render_pass(RenderPassDesc {
    color_attachments: vec![
        ColorAttachmentDesc {
            format: swapchain.format(),
            load_op: LoadOp::Clear,
            store_op: StoreOp::Store,
        },
    ],
    depth_attachment: None,
})?;
</code></pre>
                    </div>
                </div>

                <h3 id="renderer-submission">Command Submission</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('submit-with-sync')">
                        <span>submit_with_sync()</span>
                        <span class="summary">Submits command list with swapchain synchronization</span>
                    </h3>
                    <div id="submit-with-sync" class="accordion-content">
                        <p>
                            Submits a command list to the GPU queue with proper synchronization for swapchain presentation.
                            Waits for image available semaphore and signals render finished semaphore.
                        </p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>command_list: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::CommandList&gt;</code> - The command list to submit</li>
                            <li><code>sync_info: &SwapchainSyncInfo</code> - Synchronization info from swapchain</li>
                            <li><code>image_index: u32</code> - Index of the swapchain image</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">// Typical render loop
let (image_index, render_target) = swapchain.acquire_next_image()?;

command_list.begin()?;
command_list.begin_render_pass(&render_pass, &render_target, &clear_values)?;
// ... record drawing commands ...
command_list.end_render_pass()?;
command_list.end()?;

let sync_info = swapchain.sync_info();
renderer.submit_with_sync(&command_list, &sync_info, image_index)?;

swapchain.present(image_index)?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Command List -->
            <section id="command-list">
                <h2>Command List</h2>
                <p>See <a href="#create-command-list">Renderer::create_command_list()</a> for command list creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::CommandList Trait</h3>
                <p>Interface for recording rendering commands. Command lists are reusable and must be begun/ended each frame.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-begin')">
                        <span>begin()</span>
                        <span class="summary">Begins recording commands</span>
                    </h3>
                    <div id="cmd-begin" class="accordion-content">
                        <p>Starts recording commands into the command list. Must be called before any other recording commands.</p>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.begin()?;
// ... record commands ...
command_list.end()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-begin-render-pass')">
                        <span>begin_render_pass()</span>
                        <span class="summary">Begins a render pass</span>
                    </h3>
                    <div id="cmd-begin-render-pass" class="accordion-content">
                        <p>Begins a render pass with specified render target and clear values.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>render_pass: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderPass&gt;</code></li>
                            <li><code>render_target: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderTarget&gt;</code></li>
                            <li><code>clear_values: &[ClearValue]</code></li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let clear_values = [
    ClearValue::Color([0.0, 0.0, 0.0, 1.0]), // Black clear color
];

command_list.begin_render_pass(&render_pass, &render_target, &clear_values)?;
// ... draw commands ...
command_list.end_render_pass()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-pipeline')">
                        <span>bind_pipeline()</span>
                        <span class="summary">Binds a graphics pipeline</span>
                    </h3>
                    <div id="cmd-bind-pipeline" class="accordion-content">
                        <p>Binds a graphics pipeline for subsequent draw commands.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>pipeline: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;</code></li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_pipeline(&pipeline)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-vertex-buffer')">
                        <span>bind_vertex_buffer()</span>
                        <span class="summary">Binds a vertex buffer</span>
                    </h3>
                    <div id="cmd-bind-vertex-buffer" class="accordion-content">
                        <p>Binds a vertex buffer to a binding slot.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>buffer: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;</code></li>
                            <li><code>binding: u32</code> - Binding slot (usually 0)</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_vertex_buffer(&vertex_buffer, 0)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-index-buffer')">
                        <span>bind_index_buffer()</span>
                        <span class="summary">Binds an index buffer</span>
                    </h3>
                    <div id="cmd-bind-index-buffer" class="accordion-content">
                        <p>Binds an index buffer for indexed drawing.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>buffer: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Buffer&gt;</code></li>
                            <li><code>offset: u64</code> - Offset in bytes (usually 0)</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_index_buffer(&index_buffer, 0)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-bind-descriptor-sets')">
                        <span>bind_descriptor_sets()</span>
                        <span class="summary">Binds descriptor sets (textures, uniforms)</span>
                    </h3>
                    <div id="cmd-bind-descriptor-sets" class="accordion-content">
                        <p>Binds descriptor sets containing textures and uniform buffers.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>pipeline: &Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::Pipeline&gt;</code></li>
                            <li><code>descriptor_sets: &[&Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::DescriptorSet&gt;]</code></li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.bind_descriptor_sets(&pipeline, &[&texture_descriptor])?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-push-constants')">
                        <span>push_constants()</span>
                        <span class="summary">Updates push constant data</span>
                    </h3>
                    <div id="cmd-push-constants" class="accordion-content">
                        <p>Updates push constant data for fast per-draw parameters (transforms, time, etc.).</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>offset: u32</code> - Offset in push constant block</li>
                            <li><code>data: &[u8]</code> - Raw bytes to push</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let time: f32 = elapsed_time;
command_list.push_constants(0, &time.to_le_bytes())?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-draw')">
                        <span>draw()</span>
                        <span class="summary">Issues a draw call</span>
                    </h3>
                    <div id="cmd-draw" class="accordion-content">
                        <p>Draws non-indexed vertices.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>vertex_count: u32</code></li>
                            <li><code>first_vertex: u32</code></li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.draw(3, 0)?; // Draw 3 vertices (1 triangle)
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-draw-indexed')">
                        <span>draw_indexed()</span>
                        <span class="summary">Issues an indexed draw call</span>
                    </h3>
                    <div id="cmd-draw-indexed" class="accordion-content">
                        <p>Draws indexed geometry.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>index_count: u32</code></li>
                            <li><code>first_index: u32</code></li>
                            <li><code>vertex_offset: i32</code></li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.draw_indexed(6, 0, 0)?; // Draw 6 indices (2 triangles)
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-set-viewport')">
                        <span>set_viewport()</span>
                        <span class="summary">Sets the viewport</span>
                    </h3>
                    <div id="cmd-set-viewport" class="accordion-content">
                        <p>Sets the viewport for rendering.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>viewport: Viewport</code></li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.set_viewport(Viewport {
    x: 0.0,
    y: 0.0,
    width: 800.0,
    height: 600.0,
    min_depth: 0.0,
    max_depth: 1.0,
})?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-end-render-pass')">
                        <span>end_render_pass()</span>
                        <span class="summary">Ends the current render pass</span>
                    </h3>
                    <div id="cmd-end-render-pass" class="accordion-content">
                        <p>Ends the currently active render pass.</p>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.end_render_pass()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('cmd-end')">
                        <span>end()</span>
                        <span class="summary">Finishes recording commands</span>
                    </h3>
                    <div id="cmd-end" class="accordion-content">
                        <p>Finishes recording and finalizes the command list for submission.</p>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">command_list.end()?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Swapchain -->
            <section id="swapchain">
                <h2>Swapchain</h2>
                <p>See <a href="#create-swapchain">Renderer::create_swapchain()</a> for swapchain creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::Swapchain Trait</h3>
                <p>Manages presentation to a window with proper image acquisition and presentation synchronization.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-acquire')">
                        <span>acquire_next_image()</span>
                        <span class="summary">Acquires the next swapchain image for rendering</span>
                    </h3>
                    <div id="swap-acquire" class="accordion-content">
                        <p>Acquires the next available image from the swapchain. Returns the image index and a render target.</p>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;(u32, Arc&lt;dyn galaxy_3d_engine::galaxy3d::render::RenderTarget&gt;)&gt;</code></p>
                        <pre><code class="language-rust">let (image_index, render_target) = swapchain.acquire_next_image()?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-present')">
                        <span>present()</span>
                        <span class="summary">Presents the rendered image to the screen</span>
                    </h3>
                    <div id="swap-present" class="accordion-content">
                        <p>Presents the specified image index to the screen after rendering is complete.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>image_index: u32</code> - The image index from acquire_next_image</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">swapchain.present(image_index)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-sync-info')">
                        <span>sync_info()</span>
                        <span class="summary">Gets synchronization info for command submission</span>
                    </h3>
                    <div id="swap-sync-info" class="accordion-content">
                        <p>Returns synchronization information needed for submit_with_sync().</p>
                        <p><strong>Returns:</strong> <code>SwapchainSyncInfo</code></p>
                        <pre><code class="language-rust">let sync_info = swapchain.sync_info();
renderer.submit_with_sync(&command_list, &sync_info, image_index)?;
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('swap-format')">
                        <span>format()</span>
                        <span class="summary">Gets the swapchain image format</span>
                    </h3>
                    <div id="swap-format" class="accordion-content">
                        <p>Returns the pixel format of swapchain images.</p>
                        <p><strong>Returns:</strong> <code>TextureFormat</code></p>
                        <pre><code class="language-rust">let format = swapchain.format();
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Render Target -->
            <section id="render-target">
                <h2>Render Target</h2>
                <p>Represents a rendering destination (either swapchain image or texture).</p>

                <h3>galaxy_3d_engine::galaxy3d::render::RenderTarget Trait</h3>
                <div class="note">
                    <strong>Note:</strong> galaxy_3d_engine::galaxy3d::render::RenderTarget is a marker trait with no public methods. It is used for type safety to prevent accidental misuse of render target handles. Render targets are typically obtained from swapchain.acquire_next_image() or created from textures.
                </div>
            </section>

            <!-- Render Pass -->
            <section id="render-pass">
                <h2>Render Pass</h2>
                <p>See <a href="#create-render-pass">Renderer::create_render_pass()</a> for render pass creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::RenderPass Trait</h3>
                <p>Defines the rendering configuration including color/depth attachments and load/store operations.</p>

                <div class="note">
                    <strong>Note:</strong> galaxy_3d_engine::galaxy3d::render::RenderPass is a marker trait with no public methods. It is used for type safety to prevent accidental misuse of render pass handles.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('renderpass-desc')">
                        <span>RenderPassDesc</span>
                        <span class="summary">Render pass description structure</span>
                    </h3>
                    <div id="renderpass-desc" class="accordion-content">
                        <p>Describes a render pass configuration.</p>
                        <pre><code class="language-rust">let render_pass = renderer.create_render_pass(RenderPassDesc {
    color_attachments: vec![
        ColorAttachmentDesc {
            format: swapchain.format(),
            load_op: LoadOp::Clear,   // Clear on load
            store_op: StoreOp::Store, // Store result
        },
    ],
    depth_attachment: None,
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Pipeline -->
            <section id="pipeline">
                <h2>Pipeline</h2>
                <p>See <a href="#create-pipeline">Renderer::create_pipeline()</a> for pipeline creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::Pipeline Trait</h3>
                <p>Graphics pipeline state including shaders, vertex layout, topology, and blending.</p>

                <div class="note">
                    <strong>Note:</strong> galaxy_3d_engine::galaxy3d::render::Pipeline is a marker trait with no public methods. It is used for type safety to prevent accidental misuse of pipeline handles.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('pipeline-desc')">
                        <span>PipelineDesc</span>
                        <span class="summary">Pipeline description structure</span>
                    </h3>
                    <div id="pipeline-desc" class="accordion-content">
                        <p>Complete pipeline configuration including:</p>
                        <ul>
                            <li>Vertex and fragment shaders</li>
                            <li>Vertex layout (bindings and attributes)</li>
                            <li>Primitive topology</li>
                            <li>Push constant ranges</li>
                            <li>Descriptor set layouts</li>
                            <li>Blending configuration</li>
                        </ul>
                        <pre><code class="language-rust">let pipeline = renderer.create_pipeline(PipelineDesc {
    vertex_shader: vertex_shader.clone(),
    fragment_shader: fragment_shader.clone(),
    vertex_layout: VertexLayout {
        bindings: vec![
            VertexBinding {
                binding: 0,
                stride: 20,
                input_rate: VertexInputRate::Vertex,
            },
        ],
        attributes: vec![
            VertexAttribute {
                location: 0,
                binding: 0,
                format: VertexFormat::Float3,
                offset: 0,
            },
        ],
    },
    topology: PrimitiveTopology::TriangleList,
    push_constant_ranges: vec![
        PushConstantRange {
            stages: vec![ShaderStage::Vertex],
            offset: 0,
            size: 16, // 4 floats
        },
    ],
    descriptor_set_layouts: vec![],
    enable_blending: true, // Enable alpha blending
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Buffer -->
            <section id="buffer">
                <h2>Buffer</h2>
                <p>See <a href="#create-buffer">Renderer::create_buffer()</a> for buffer creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::Buffer Trait</h3>
                <p>GPU buffer for storing vertex data, index data, or uniform data.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('buffer-update')">
                        <span>update()</span>
                        <span class="summary">Updates buffer data</span>
                    </h3>
                    <div id="buffer-update" class="accordion-content">
                        <p>Updates the buffer contents with new data.</p>
                        <p><strong>Parameters:</strong></p>
                        <ul>
                            <li><code>offset: u64</code> - Offset in bytes</li>
                            <li><code>data: &[u8]</code> - New data</li>
                        </ul>
                        <p><strong>Returns:</strong> <code>galaxy_3d_engine::galaxy3d::Result&lt;()&gt;</code></p>
                        <pre><code class="language-rust">let new_vertex_data: Vec&lt;f32&gt; = vec![/* updated vertices */];
vertex_buffer.update(0, bytemuck::cast_slice(&new_vertex_data))?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Texture -->
            <section id="texture">
                <h2>Texture</h2>
                <p>See <a href="#create-texture">Renderer::create_texture()</a> for texture creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::Texture Trait</h3>
                <p>GPU texture for sampling in shaders. Supports both simple 2D textures and texture arrays.</p>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-info')">
                        <span>info()</span>
                        <span class="summary">Get read-only texture properties</span>
                    </h3>
                    <div id="texture-info" class="accordion-content">
                        <p>Returns a reference to the texture's read-only properties.</p>
                        <p><strong>Returns:</strong> <code>&amp;TextureInfo</code></p>
                        <pre><code class="language-rust">let texture = renderer.create_texture(desc)?;
let info = texture.info();
println!("Size: {}x{}, layers: {}", info.width, info.height, info.array_layers);
println!("Is array: {}", info.is_array());
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-info-struct')">
                        <span>TextureInfo</span>
                        <span class="summary">Read-only texture properties</span>
                    </h3>
                    <div id="texture-info-struct" class="accordion-content">
                        <pre><code class="language-rust">pub struct TextureInfo {
    pub width: u32,
    pub height: u32,
    pub format: TextureFormat,
    pub usage: TextureUsage,
    pub array_layers: u32,
}

impl TextureInfo {
    pub fn is_array(&amp;self) -&gt; bool { self.array_layers &gt; 1 }
}
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-desc')">
                        <span>TextureDesc</span>
                        <span class="summary">Texture creation descriptor</span>
                    </h3>
                    <div id="texture-desc" class="accordion-content">
                        <pre><code class="language-rust">pub struct TextureDesc {
    pub width: u32,
    pub height: u32,
    pub format: TextureFormat,
    pub usage: TextureUsage,
    pub array_layers: u32,           // 1 = simple 2D, &gt;1 = texture array
    pub data: Option&lt;TextureData&gt;,   // Optional initial data
}
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-data')">
                        <span>TextureData</span>
                        <span class="summary">Initial texture data for upload</span>
                    </h3>
                    <div id="texture-data" class="accordion-content">
                        <pre><code class="language-rust">pub enum TextureData {
    /// Single image data (for simple textures, or layer 0 of an array)
    Single(Vec&lt;u8&gt;),

    /// Per-layer data for array textures.
    /// Only the layers listed are uploaded; others remain uninitialized.
    Layers(Vec&lt;TextureLayerData&gt;),
}

pub struct TextureLayerData {
    pub layer: u32,      // Target layer index (0-based)
    pub data: Vec&lt;u8&gt;,   // Raw pixel bytes for this layer
}
</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('texture-formats')">
                        <span>TextureFormat</span>
                        <span class="summary">Supported texture formats</span>
                    </h3>
                    <div id="texture-formats" class="accordion-content">
                        <p>Common texture formats:</p>
                        <ul>
                            <li><code>R8G8B8A8_SRGB</code> - 8-bit RGBA with sRGB color space</li>
                            <li><code>R8G8B8A8_UNORM</code> - 8-bit RGBA linear</li>
                            <li><code>B8G8R8A8_SRGB</code> - 8-bit BGRA with sRGB (common for swapchains)</li>
                        </ul>
                        <pre><code class="language-rust">let texture = renderer.create_texture(TextureDesc {
    width: 512,
    height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    array_layers: 1,
    data: Some(TextureData::Single(image_data)),
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Shader -->
            <section id="shader">
                <h2>Shader</h2>
                <p>See <a href="#create-shader">Renderer::create_shader()</a> for shader creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::Shader Trait</h3>
                <p>Compiled shader module (SPIR-V bytecode).</p>

                <div class="note">
                    <strong>Note:</strong> galaxy_3d_engine::galaxy3d::render::Shader is a marker trait with no public methods. It is used for type safety to prevent accidental misuse of shader handles.
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('shader-stages')">
                        <span>ShaderStage</span>
                        <span class="summary">Shader stage types</span>
                    </h3>
                    <div id="shader-stages" class="accordion-content">
                        <p>Supported shader stages:</p>
                        <ul>
                            <li><code>ShaderStage::Vertex</code> - Vertex shader</li>
                            <li><code>ShaderStage::Fragment</code> - Fragment/pixel shader</li>
                            <li><code>ShaderStage::Compute</code> - Compute shader (future)</li>
                        </ul>
                        <pre><code class="language-rust">let vertex_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Vertex,
    code: include_bytes!("shader.vert.spv"),
})?;

let fragment_shader = renderer.create_shader(ShaderDesc {
    stage: ShaderStage::Fragment,
    code: include_bytes!("shader.frag.spv"),
})?;
</code></pre>
                    </div>
                </div>
            </section>

            <!-- Descriptor Set -->
            <section id="descriptor-set">
                <h2>Descriptor Set</h2>
                <p>See <a href="#create-descriptor-set">Renderer::create_descriptor_set_for_texture()</a> for descriptor set creation.</p>

                <h3>galaxy_3d_engine::galaxy3d::render::DescriptorSet Trait</h3>
                <p>Binds resources (textures, uniform buffers) to shaders.</p>

                <div class="note">
                    <strong>Note:</strong> galaxy_3d_engine::galaxy3d::render::DescriptorSet is a marker trait with no public methods. It is used for type safety to prevent accidental misuse of descriptor set handles. Currently, descriptor sets are created specifically for textures using <code>create_descriptor_set_for_texture()</code>. Future versions will support custom descriptor layouts.
                </div>

                <pre><code class="language-rust">// Create texture and descriptor set
let texture = renderer.create_texture(texture_desc)?;
let descriptor_set = renderer.create_descriptor_set_for_texture(&texture)?;

// Use in rendering
command_list.bind_descriptor_sets(&pipeline, &[&descriptor_set])?;
</code></pre>
            </section>

            <!-- Logger -->
            <section id="logger">
                <h2>Logger</h2>
                <p>See <a href="#set-logger">Engine::set_logger()</a> for logger installation.</p>

                <h3>galaxy_3d_engine::galaxy3d::log::Logger Trait</h3>
                <p>Custom logger interface to intercept and route engine internal logs.</p>

                <div class="note">
                    <strong>Note:</strong> The Logger trait allows users to implement custom logging backends (e.g., tracing, slog, log4rs) to capture Galaxy3D Engine's internal logs. The engine uses this logger for all internal messages via internal macros (not exposed in public API).
                </div>

                <h4>Trait Definition</h4>
                <pre><code class="language-rust">pub trait Logger: Send + Sync {
    fn log(&self, entry: &LogEntry);
}

pub struct LogEntry&lt;'a&gt; {
    pub severity: LogSeverity,
    pub source: &'a str,       // e.g., "galaxy3d::vulkan::Renderer"
    pub message: &'a str,
    pub file: Option&lt;&'a str&gt;, // File path (only for errors)
    pub line: Option&lt;u32&gt;,     // Line number (only for errors)
}

pub enum LogSeverity {
    Trace,   // Verbose debugging information
    Debug,   // Detailed debug information
    Info,    // Informational messages
    Warn,    // Warning messages
    Error,   // Error messages
}</code></pre>

                <h4>Example: TracingLogger Implementation</h4>
                <pre><code class="language-rust">use galaxy_3d_engine::galaxy3d::log::{Logger, LogEntry, LogSeverity};
use tracing::Level;

pub struct TracingLogger {
    // ... fields ...
}

impl Logger for TracingLogger {
    fn log(&self, entry: &LogEntry) {
        // Convert LogSeverity to tracing::Level
        let level = match entry.severity {
            LogSeverity::Trace => Level::TRACE,
            LogSeverity::Debug => Level::DEBUG,
            LogSeverity::Info => Level::INFO,
            LogSeverity::Warn => Level::WARN,
            LogSeverity::Error => Level::ERROR,
        };

        // Format message with source module
        let full_message = if let (Some(file), Some(line)) = (entry.file, entry.line) {
            format!("[{}] {} ({}:{})", entry.source, entry.message, file, line)
        } else {
            format!("[{}] {}", entry.source, entry.message)
        };

        // Route to tracing
        match level {
            Level::TRACE => tracing::trace!("{}", full_message),
            Level::DEBUG => tracing::debug!("{}", full_message),
            Level::INFO => tracing::info!("{}", full_message),
            Level::WARN => tracing::warn!("{}", full_message),
            Level::ERROR => tracing::error!("{}", full_message),
        }
    }
}

// Install custom logger
fn main() {
    galaxy3d::Engine::initialize()?;

    let logger = TracingLogger::new("app.log")?;
    galaxy3d::Engine::set_logger(logger);

    // All engine logs will now route to your logger
}</code></pre>

                <h4>DefaultLogger</h4>
                <p>If no custom logger is installed, the engine uses <code>DefaultLogger</code> which outputs to console with colors and timestamps:</p>
                <pre><code class="language-bash">[2026-01-31 17:18:30.120] [INFO ] [galaxy3d::vulkan::Renderer] Vulkan renderer initialized
[2026-01-31 17:18:30.234] [ERROR] [galaxy3d::vulkan::Swapchain] Failed to acquire image (vulkan_swapchain.rs:142)</code></pre>

                <div class="note">
                    <strong>Important:</strong> The engine's internal logging macros (<code>engine_trace!</code>, <code>engine_debug!</code>, <code>engine_info!</code>, <code>engine_warn!</code>, <code>engine_error!</code>) are hidden from the public API (<code>#[doc(hidden)]</code>) and should NOT be used by applications. Applications should implement the Logger trait to capture engine logs.
                </div>
            </section>

            <!-- Resource Textures -->
            <section id="resource-texture">
                <a href="#toc" class="back-to-toc">â†‘ Table of Contents</a>
                <h2>Resource Textures</h2>
                <p>Resource-level texture types that wrap low-level <code>render::Texture</code> (GPU) objects with additional metadata for the resource system. Part of the 3-level texture architecture:</p>
                <ul>
                    <li><strong>render::Texture</strong> â€” GPU handle (low-level, backend-specific)</li>
                    <li><strong>resource::Texture</strong> â€” Named resource with sub-regions (this module)</li>
                    <li><strong>scene::Texture</strong> â€” Scene object (future)</li>
                </ul>

                <h3 id="resource-texture-trait">Texture Trait</h3>
                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-texture-trait-detail')">
                        resource::Texture
                        <span class="summary">Trait for uniform access to any texture resource</span>
                    </h3>
                    <div id="resource-texture-trait-detail" class="accordion-content">
                        <p>Provides uniform access to any texture resource regardless of its concrete type (simple, atlas, or array). Uses trait objects (<code>dyn Texture</code>) for dynamic dispatch â€” similar to C++ virtual inheritance.</p>
                        <pre><code>pub trait Texture: Send + Sync {
    fn render_texture(&amp;self) -&gt; &amp;Arc&lt;dyn render::Texture&gt;;
    fn descriptor_set(&amp;self) -&gt; &amp;Arc&lt;dyn DescriptorSet&gt;;
    fn region_names(&amp;self) -&gt; Vec&lt;&amp;str&gt;;

    // Downcast methods (return None for wrong type)
    fn as_simple(&amp;self) -&gt; Option&lt;&amp;SimpleTexture&gt;;
    fn as_atlas(&amp;self) -&gt; Option&lt;&amp;AtlasTexture&gt;;
    fn as_atlas_mut(&amp;mut self) -&gt; Option&lt;&amp;mut AtlasTexture&gt;;
    fn as_array(&amp;self) -&gt; Option&lt;&amp;ArrayTexture&gt;;
    fn as_array_mut(&amp;mut self) -&gt; Option&lt;&amp;mut ArrayTexture&gt;;
}</code></pre>
                    </div>
                </div>

                <h3 id="resource-texture-types">Concrete Types</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-simple-texture')">
                        SimpleTexture
                        <span class="summary">Single texture with no sub-regions</span>
                    </h3>
                    <div id="resource-simple-texture" class="accordion-content">
                        <p>The simplest resource texture type â€” wraps a GPU texture and its descriptor set with no additional metadata. One texture = one image, 1:1 mapping.</p>
                        <pre><code>pub struct SimpleTexture {
    render_texture: Arc&lt;dyn render::Texture&gt;,
    descriptor_set: Arc&lt;dyn DescriptorSet&gt;,
}</code></pre>
                        <p><strong>Usage:</strong></p>
                        <pre><code>// Created via ResourceManager
let rm = Engine::resource_manager()?;
let mut rm_guard = rm.lock().unwrap();
rm_guard.create_simple_texture("skybox".into(), TextureDesc {
    width: 512, height: 512,
    format: TextureFormat::R8G8B8A8_SRGB,
    usage: TextureUsage::Sampled,
    data: Some(image_data),
})?;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-atlas-texture')">
                        AtlasTexture
                        <span class="summary">Texture atlas with named UV regions</span>
                    </h3>
                    <div id="resource-atlas-texture" class="accordion-content">
                        <p>Wraps a single GPU texture that contains multiple sub-images arranged spatially. Each sub-image is identified by name and described by UV coordinates (<code>AtlasRegion</code>).</p>
                        <pre><code>pub struct AtlasTexture {
    render_texture: Arc&lt;dyn render::Texture&gt;,
    descriptor_set: Arc&lt;dyn DescriptorSet&gt;,
    regions: HashMap&lt;String, AtlasRegion&gt;,
}

pub struct AtlasRegion {
    pub u: f32,      // Left edge (0.0..1.0)
    pub v: f32,      // Top edge (0.0..1.0)
    pub width: f32,  // Width in UV space
    pub height: f32, // Height in UV space
}</code></pre>
                        <p>Regions can be provided at creation time and/or added later:</p>
                        <pre><code>// Create with regions
rm_guard.create_atlas_texture("tileset".into(), desc, &amp;[
    AtlasRegionDesc { name: "grass".into(), region: AtlasRegion { u: 0.0, v: 0.0, width: 0.25, height: 0.25 } },
    AtlasRegionDesc { name: "stone".into(), region: AtlasRegion { u: 0.25, v: 0.0, width: 0.25, height: 0.25 } },
])?;

// Or create empty and add later
rm_guard.create_atlas_texture("sprites".into(), desc, &amp;[])?;
rm_guard.add_atlas_region("sprites", "player".into(),
    AtlasRegion { u: 0.0, v: 0.0, width: 0.5, height: 0.5 })?;

// Access a region
let tex = rm_guard.texture("tileset").unwrap();
let atlas = tex.as_atlas().unwrap();
let grass = atlas.get_region("grass").unwrap();</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-array-texture')">
                        ArrayTexture
                        <span class="summary">Texture array with named layers</span>
                    </h3>
                    <div id="resource-array-texture" class="accordion-content">
                        <p>Wraps a GPU texture array where each layer is identified by name and mapped to a layer index.</p>
                        <pre><code>pub struct ArrayTexture {
    render_texture: Arc&lt;dyn render::Texture&gt;,
    descriptor_set: Arc&lt;dyn DescriptorSet&gt;,
    layers: HashMap&lt;String, u32&gt;,
}

pub struct ArrayLayerDesc {
    pub name: String,           // Layer name
    pub layer: u32,             // Layer index in the texture array
    pub data: Option&lt;Vec&lt;u8&gt;&gt;,  // Optional pixel data to upload
}</code></pre>
                        <p>Layers can be provided at creation time (with optional pixel data) and/or added later:</p>
                        <pre><code>// Create with layers and upload pixel data
rm_guard.create_array_texture("terrain".into(), desc, &amp;[
    ArrayLayerDesc { name: "grass".into(), layer: 0, data: Some(grass_pixels) },
    ArrayLayerDesc { name: "dirt".into(), layer: 1, data: Some(dirt_pixels) },
])?;

// Or create empty and add later with optional data upload
rm_guard.create_array_texture("materials".into(), desc, &amp;[])?;
rm_guard.add_array_layer("materials", "wood".into(), 0, Some(&amp;wood_pixels))?;
rm_guard.add_array_layer("materials", "metal".into(), 1, None)?;  // No data upload</code></pre>
                    </div>
                </div>

                <h3 id="resource-texture-manager">ResourceManager Texture API</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-simple')">
                        ResourceManager::create_simple_texture()
                        <span class="summary">Create and register a simple texture</span>
                    </h3>
                    <div id="rm-create-simple" class="accordion-content">
                        <p>Creates a GPU texture and descriptor set via the renderer, then registers the resource. Returns the created texture for immediate use.</p>
                        <p><strong>Validation:</strong> <code>desc.array_layers</code> must be 1.</p>
                        <pre><code>pub fn create_simple_texture(&amp;mut self, name: String, desc: TextureDesc) -&gt; Result&lt;Arc&lt;dyn Texture&gt;&gt;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-atlas')">
                        ResourceManager::create_atlas_texture()
                        <span class="summary">Create and register an atlas texture</span>
                    </h3>
                    <div id="rm-create-atlas" class="accordion-content">
                        <p>Creates a GPU texture + descriptor set, then wraps it as an AtlasTexture with optional initial regions. Pass <code>&amp;[]</code> for regions to add them later. Returns the created texture for immediate use.</p>
                        <p><strong>Validation:</strong> <code>desc.array_layers</code> must be 1 (atlas uses UV regions, not array layers).</p>
                        <pre><code>pub fn create_atlas_texture(&amp;mut self, name: String, desc: TextureDesc, regions: &amp;[AtlasRegionDesc]) -&gt; Result&lt;Arc&lt;dyn Texture&gt;&gt;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-array')">
                        ResourceManager::create_array_texture()
                        <span class="summary">Create and register an array texture</span>
                    </h3>
                    <div id="rm-create-array" class="accordion-content">
                        <p>Creates a GPU texture array + descriptor set, then wraps it as an ArrayTexture with optional initial layer mappings. If any <code>ArrayLayerDesc</code> has <code>data</code>, pixel data is uploaded at creation. Returns the created texture for immediate use.</p>
                        <p><strong>Validation:</strong> <code>desc.array_layers</code> must be &gt; 1. Layer indices in <code>layers</code> must be &lt; <code>desc.array_layers</code>.</p>
                        <pre><code>pub fn create_array_texture(&amp;mut self, name: String, desc: TextureDesc, layers: &amp;[ArrayLayerDesc]) -&gt; Result&lt;Arc&lt;dyn Texture&gt;&gt;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-get-texture')">
                        ResourceManager::texture() / remove_texture() / texture_count()
                        <span class="summary">Access and manage registered textures</span>
                    </h3>
                    <div id="rm-get-texture" class="accordion-content">
                        <pre><code>pub fn texture(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Arc&lt;dyn Texture&gt;&gt;
pub fn remove_texture(&amp;mut self, name: &amp;str) -&gt; bool
pub fn texture_count(&amp;self) -&gt; usize</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-add-region-layer')">
                        ResourceManager::add_atlas_region() / add_array_layer()
                        <span class="summary">Add regions/layers to existing textures post-creation</span>
                    </h3>
                    <div id="rm-add-region-layer" class="accordion-content">
                        <p>Uses <code>Arc::get_mut</code> for safe mutable access. Fails if other references to the texture Arc exist. <code>add_array_layer</code> accepts optional pixel data to upload.</p>
                        <pre><code>pub fn add_atlas_region(&amp;mut self, texture_name: &amp;str, region_name: String, region: AtlasRegion) -&gt; Result&lt;()&gt;
pub fn add_array_layer(&amp;mut self, texture_name: &amp;str, layer_name: String, layer: u32, data: Option&lt;&amp;[u8]&gt;) -&gt; Result&lt;()&gt;</code></pre>
                    </div>
                </div>
            </section>

            <!-- Resource Meshes -->
            <section id="resource-mesh">
                <a href="#toc" class="back-to-toc">â†‘ Table of Contents</a>
                <h2>Resource Meshes</h2>
                <p>Resource-level mesh types that wrap low-level GPU buffers with a structured 4-level hierarchy. Part of the resource management system:</p>
                <ul>
                    <li><strong>render::Buffer</strong> â€” GPU buffers (low-level, backend-specific)</li>
                    <li><strong>resource::Mesh</strong> â€” Named resource with entries, LODs, and submeshes (this module)</li>
                    <li><strong>scene::Mesh</strong> â€” Scene object (future)</li>
                </ul>

                <h3 id="resource-mesh-hierarchy">4-Level Hierarchy</h3>
                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-hierarchy-detail')">
                        Mesh Hierarchy Overview
                        <span class="summary">Mesh â†’ MeshEntry â†’ MeshLOD â†’ SubMesh</span>
                    </h3>
                    <div id="resource-mesh-hierarchy-detail" class="accordion-content">
                        <p>The mesh system uses a 4-level hierarchy designed for complex 3D models with multiple parts, LOD levels, and materials. Uses the <strong>Vec+HashMap pattern</strong> for O(1) access by both id (index) and name:</p>
                        <pre><code>Mesh (group resource)
â”œâ”€â”€ name: "characters"
â”œâ”€â”€ vertex_buffer: Arc&lt;dyn Buffer&gt;       // Shared by all
â”œâ”€â”€ index_buffer: Option&lt;Arc&lt;dyn Buffer&gt;&gt; // Shared by all (optional)
â”œâ”€â”€ vertex_layout: VertexLayout           // Shared by all
â”œâ”€â”€ index_type: IndexType                 // U16 or U32
â”œâ”€â”€ total_vertex_count: u32
â”œâ”€â”€ total_index_count: u32
â”‚
â”œâ”€â”€ mesh_entries: Vec&lt;MeshEntry&gt;          // Storage by id (index)
â””â”€â”€ entry_names: HashMap&lt;String, usize&gt;   // Name â†’ id mapping
    â”œâ”€â”€ "hero" â†’ 0
    â”‚   â””â”€â”€ lods: Vec&lt;MeshLOD&gt;
    â”‚       â”œâ”€â”€ [0] LOD 0 (high detail)
    â”‚       â”‚   â”œâ”€â”€ submeshes: Vec&lt;SubMesh&gt;
    â”‚       â”‚   â””â”€â”€ submesh_names: HashMap&lt;String, usize&gt;
    â”‚       â”‚       â”œâ”€â”€ "body" â†’ 0
    â”‚       â”‚       â””â”€â”€ "armor" â†’ 1
    â”‚       â””â”€â”€ [1] LOD 1 (low detail)
    â””â”€â”€ "enemy" â†’ 1
        â””â”€â”€ ...</code></pre>
                        <p><strong>Design Principles:</strong></p>
                        <ul>
                            <li><strong>Vec+HashMap pattern:</strong> <code>Vec&lt;T&gt;</code> for storage + <code>HashMap&lt;String, usize&gt;</code> for name lookup</li>
                            <li><strong>ID-based access:</strong> Methods return IDs (<code>usize</code>) for fast subsequent access</li>
                            <li>Single buffer pair per Mesh: All entries share vertex/index buffers (GPU efficient)</li>
                            <li>Raw data input: MeshDesc takes <code>Vec&lt;u8&gt;</code>, ResourceManager creates GPU buffers</li>
                            <li>Automatic validation: Submesh offsets validated against buffer sizes</li>
                            <li>Automatic count calculation: Vertex/index counts computed from data length and stride</li>
                        </ul>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-struct')">
                        Mesh
                        <span class="summary">Top-level mesh group resource</span>
                    </h3>
                    <div id="resource-mesh-struct" class="accordion-content">
                        <p>The top-level mesh resource containing shared GPU buffers and named entries. Uses Vec+HashMap pattern for O(1) access by id or name.</p>
                        <pre><code>pub struct Mesh {
    name: String,
    vertex_buffer: Arc&lt;dyn render::Buffer&gt;,
    index_buffer: Option&lt;Arc&lt;dyn render::Buffer&gt;&gt;,
    vertex_layout: VertexLayout,
    index_type: IndexType,
    total_vertex_count: u32,
    total_index_count: u32,
    mesh_entries: Vec&lt;MeshEntry&gt;,           // Storage by id (index)
    entry_names: HashMap&lt;String, usize&gt;,    // Name â†’ id mapping
}

impl Mesh {
    pub fn name(&amp;self) -&gt; &amp;str;
    pub fn vertex_buffer(&amp;self) -&gt; &amp;Arc&lt;dyn render::Buffer&gt;;
    pub fn index_buffer(&amp;self) -&gt; Option&lt;&amp;Arc&lt;dyn render::Buffer&gt;&gt;;
    pub fn is_indexed(&amp;self) -&gt; bool;
    pub fn vertex_layout(&amp;self) -&gt; &amp;VertexLayout;
    pub fn index_type(&amp;self) -&gt; IndexType;
    pub fn total_vertex_count(&amp;self) -&gt; u32;
    pub fn total_index_count(&amp;self) -&gt; u32;

    // Entry access by id (fastest - direct index)
    pub fn mesh_entry(&amp;self, id: usize) -&gt; Option&lt;&amp;MeshEntry&gt;;
    // Get id from name (for later fast access)
    pub fn mesh_entry_id(&amp;self, name: &amp;str) -&gt; Option&lt;usize&gt;;
    // Entry access by name (convenience - HashMap lookup then index)
    pub fn mesh_entry_by_name(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;MeshEntry&gt;;
    pub fn mesh_entry_names(&amp;self) -&gt; Vec&lt;&amp;str&gt;;
    pub fn mesh_entry_count(&amp;self) -&gt; usize;

    // Direct submesh access by ids (fastest)
    pub fn submesh(&amp;self, entry_id: usize, lod: usize, submesh_id: usize) -&gt; Option&lt;&amp;SubMesh&gt;;
    // Direct submesh access by names (convenience)
    pub fn submesh_by_name(&amp;self, entry_name: &amp;str, lod: usize, submesh_name: &amp;str) -&gt; Option&lt;&amp;SubMesh&gt;;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-entry')">
                        MeshEntry
                        <span class="summary">Named mesh within a group (e.g., "hero", "enemy")</span>
                    </h3>
                    <div id="resource-mesh-entry" class="accordion-content">
                        <p>A named mesh within a group, containing LOD levels. The entry name is the key in the parent Mesh's HashMap.</p>
                        <pre><code>pub struct MeshEntry {
    lods: Vec&lt;MeshLOD&gt;,  // Index 0 = most detailed
}

impl MeshEntry {
    pub fn lod(&amp;self, index: usize) -&gt; Option&lt;&amp;MeshLOD&gt;;
    pub fn lod_count(&amp;self) -&gt; usize;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-lod')">
                        MeshLOD
                        <span class="summary">Level of detail containing named submeshes</span>
                    </h3>
                    <div id="resource-mesh-lod" class="accordion-content">
                        <p>A level of detail containing named submeshes (material groups). LOD 0 is the most detailed. Uses Vec+HashMap pattern for O(1) access by id or name.</p>
                        <pre><code>pub struct MeshLOD {
    submeshes: Vec&lt;SubMesh&gt;,                // Storage by id (index)
    submesh_names: HashMap&lt;String, usize&gt;,  // Name â†’ id mapping
}

impl MeshLOD {
    // Access by id (fastest - direct index)
    pub fn submesh(&amp;self, id: usize) -&gt; Option&lt;&amp;SubMesh&gt;;
    // Get id from name (for later fast access)
    pub fn submesh_id(&amp;self, name: &amp;str) -&gt; Option&lt;usize&gt;;
    // Access by name (convenience - HashMap lookup then index)
    pub fn submesh_by_name(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;SubMesh&gt;;
    pub fn submesh_names(&amp;self) -&gt; Vec&lt;&amp;str&gt;;
    pub fn submesh_count(&amp;self) -&gt; usize;
    pub fn submeshes(&amp;self) -&gt; impl Iterator&lt;Item = (&amp;str, &amp;SubMesh)&gt;;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-submesh')">
                        SubMesh
                        <span class="summary">Drawable region with buffer offsets</span>
                    </h3>
                    <div id="resource-mesh-submesh" class="accordion-content">
                        <p>A drawable region within shared buffers. Contains all parameters for a draw call. Index fields are ignored if the parent Mesh is non-indexed.</p>
                        <pre><code>pub struct SubMesh {
    vertex_offset: u32,
    vertex_count: u32,
    index_offset: u32,   // Ignored if mesh is non-indexed
    index_count: u32,    // Ignored if mesh is non-indexed
    topology: PrimitiveTopology,
}

impl SubMesh {
    pub fn vertex_offset(&amp;self) -&gt; u32;
    pub fn vertex_count(&amp;self) -&gt; u32;
    pub fn index_offset(&amp;self) -&gt; u32;
    pub fn index_count(&amp;self) -&gt; u32;
    pub fn topology(&amp;self) -&gt; PrimitiveTopology;
}</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-index-type')">
                        IndexType
                        <span class="summary">Index buffer element type</span>
                    </h3>
                    <div id="resource-mesh-index-type" class="accordion-content">
                        <p>Specifies the element type for index buffers.</p>
                        <pre><code>pub enum IndexType {
    U16,  // 16-bit indices (max 65535 vertices)
    U32,  // 32-bit indices (max ~4 billion vertices)
}

impl IndexType {
    pub fn size_bytes(&amp;self) -&gt; u32;  // Returns 2 for U16, 4 for U32
}</code></pre>
                    </div>
                </div>

                <h3 id="resource-mesh-descriptors">Descriptor Structures</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-desc')">
                        MeshDesc
                        <span class="summary">Mesh creation descriptor with raw data</span>
                    </h3>
                    <div id="resource-mesh-desc" class="accordion-content">
                        <p>Describes a mesh for creation. Uses raw byte data â€” ResourceManager creates GPU buffers internally.</p>
                        <pre><code>pub struct MeshDesc {
    pub renderer: Arc&lt;Mutex&lt;dyn Renderer&gt;&gt;, // Renderer for GPU buffer creation
    pub vertex_data: Vec&lt;u8&gt;,           // Raw interleaved vertex data
    pub index_data: Option&lt;Vec&lt;u8&gt;&gt;,    // Raw index data (None for non-indexed)
    pub vertex_layout: VertexLayout,     // Defines stride for vertex count
    pub index_type: IndexType,           // U16 or U32
    pub meshes: Vec&lt;MeshEntryDesc&gt;,      // Initial mesh entries (can be empty)
}</code></pre>
                        <p><strong>Validation:</strong></p>
                        <ul>
                            <li><code>vertex_data.len()</code> must be divisible by <code>vertex_layout.stride()</code></li>
                            <li>If <code>index_data</code> is provided, its length must be divisible by <code>index_type.size_bytes()</code></li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <pre><code>let desc = MeshDesc {
    renderer: renderer.clone(),
    vertex_data: vertex_bytes,
    index_data: Some(index_bytes),
    vertex_layout: VertexLayout {
        bindings: vec![VertexBinding { binding: 0, stride: 20, input_rate: VertexInputRate::Vertex }],
        attributes: vec![
            VertexAttribute { location: 0, binding: 0, format: VertexFormat::Float3, offset: 0 },
            VertexAttribute { location: 1, binding: 0, format: VertexFormat::Float2, offset: 12 },
        ],
    },
    index_type: IndexType::U16,
    meshes: vec![
        MeshEntryDesc {
            name: "hero".into(),
            lods: vec![
                MeshLODDesc {
                    lod_index: 0,
                    submeshes: vec![
                        SubMeshDesc {
                            name: "body".into(),
                            vertex_offset: 0,
                            vertex_count: 5000,
                            index_offset: 0,
                            index_count: 15000,
                            topology: PrimitiveTopology::TriangleList,
                        },
                    ],
                },
            ],
        },
    ],
};</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('resource-mesh-entry-desc')">
                        MeshEntryDesc / MeshLODDesc / SubMeshDesc
                        <span class="summary">Entry, LOD, and SubMesh descriptors</span>
                    </h3>
                    <div id="resource-mesh-entry-desc" class="accordion-content">
                        <pre><code>pub struct MeshEntryDesc {
    pub name: String,              // Entry name (key in meshes HashMap)
    pub lods: Vec&lt;MeshLODDesc&gt;,
}

pub struct MeshLODDesc {
    pub lod_index: usize,          // LOD level (0 = most detailed)
    pub submeshes: Vec&lt;SubMeshDesc&gt;,
}

pub struct SubMeshDesc {
    pub name: String,              // SubMesh name (key in submeshes HashMap)
    pub vertex_offset: u32,
    pub vertex_count: u32,
    pub index_offset: u32,         // Ignored if mesh is non-indexed
    pub index_count: u32,          // Ignored if mesh is non-indexed
    pub topology: PrimitiveTopology,
}</code></pre>
                    </div>
                </div>

                <h3 id="resource-mesh-manager">ResourceManager Mesh API</h3>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-create-mesh')">
                        ResourceManager::create_mesh()
                        <span class="summary">Create and register a mesh resource</span>
                    </h3>
                    <div id="rm-create-mesh" class="accordion-content">
                        <p>Creates GPU buffers from raw data and registers the mesh resource. Returns the created mesh for immediate use.</p>
                        <pre><code>pub fn create_mesh(&amp;mut self, name: String, desc: MeshDesc) -&gt; Result&lt;Arc&lt;Mesh&gt;&gt;</code></pre>
                        <p><strong>Validation:</strong></p>
                        <ul>
                            <li>Vertex data size must be divisible by stride</li>
                            <li>Index data size (if present) must be divisible by index element size</li>
                            <li>SubMesh ranges must be within buffer bounds</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <pre><code>let rm = Engine::resource_manager()?;
let mut rm_guard = rm.lock().unwrap();
let renderer = Engine::renderer()?;

let mesh = rm_guard.create_mesh("characters".into(), MeshDesc {
    renderer: renderer.clone(),
    vertex_data: vertex_bytes,
    index_data: Some(index_bytes),
    vertex_layout,
    index_type: IndexType::U16,
    meshes: vec![
        MeshEntryDesc {
            name: "hero".into(),
            lods: vec![
                MeshLODDesc {
                    lod_index: 0,
                    submeshes: vec![
                        SubMeshDesc {
                            name: "body".into(),
                            vertex_offset: 0,
                            vertex_count: 5000,
                            index_offset: 0,
                            index_count: 15000,
                            topology: PrimitiveTopology::TriangleList,
                        },
                    ],
                },
            ],
        },
    ],
})?;</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-mesh-access')">
                        ResourceManager::mesh() / remove_mesh() / mesh_count()
                        <span class="summary">Access and manage registered meshes</span>
                    </h3>
                    <div id="rm-mesh-access" class="accordion-content">
                        <pre><code>pub fn mesh(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Arc&lt;Mesh&gt;&gt;
pub fn remove_mesh(&amp;mut self, name: &amp;str) -&gt; bool
pub fn mesh_count(&amp;self) -&gt; usize</code></pre>
                        <p><strong>Example:</strong></p>
                        <pre><code>// Access a mesh
if let Some(mesh) = rm_guard.mesh("characters") {
    let vb = mesh.vertex_buffer();
    let ib = mesh.index_buffer();

    // Get entry id for fast access (avoids repeated HashMap lookups)
    let hero_id = mesh.mesh_entry_id("hero").unwrap();

    // Access by id (fastest) via mesh_entry() -&gt; lod() -&gt; submesh()
    if let Some(hero) = mesh.mesh_entry(hero_id) {
        if let Some(lod0) = hero.lod(0) {
            // Get submesh id for rendering
            let body_id = lod0.submesh_id("body").unwrap();
            let body = lod0.submesh(body_id).unwrap();
            // Draw submesh...

            // Or iterate over all submeshes
            for (name, submesh) in lod0.submeshes() {
                println!("Drawing submesh: {}", name);
            }
        }
    }

    // Direct access using ids (fastest)
    let body_id = mesh.mesh_entry(hero_id).unwrap().lod(0).unwrap().submesh_id("body").unwrap();
    if let Some(submesh) = mesh.submesh(hero_id, 0, body_id) {
        // Direct access by ids
    }

    // Or by names (convenience)
    if let Some(submesh) = mesh.submesh_by_name("hero", 0, "body") {
        // Direct access by names
    }
}

// Remove mesh
rm_guard.remove_mesh("old_model");</code></pre>
                    </div>
                </div>

                <div class="api-item">
                    <h3 onclick="toggleAccordion('rm-add-mesh-parts')">
                        ResourceManager::add_mesh_entry() / add_mesh_lod() / add_submesh()
                        <span class="summary">Add entries, LODs, and submeshes post-creation (returns ids)</span>
                    </h3>
                    <div id="rm-add-mesh-parts" class="accordion-content">
                        <p>Add hierarchy elements to existing meshes after creation. Uses <code>Arc::get_mut</code> for safe mutable access. <strong>Methods return ids</strong> for fast subsequent access.</p>
                        <pre><code>// Returns the id (index) of the newly created entry
pub fn add_mesh_entry(&amp;mut self, mesh_name: &amp;str, desc: MeshEntryDesc) -&gt; Result&lt;usize&gt;

// Takes entry_id (not name) and returns the lod_index
pub fn add_mesh_lod(&amp;mut self, mesh_name: &amp;str, entry_id: usize, desc: MeshLODDesc) -&gt; Result&lt;usize&gt;

// Takes entry_id (not name) and returns the submesh_id
pub fn add_submesh(&amp;mut self, mesh_name: &amp;str, entry_id: usize, lod_index: usize, desc: SubMeshDesc) -&gt; Result&lt;usize&gt;</code></pre>
                        <p><strong>Example:</strong></p>
                        <pre><code>// Add a new entry - returns its id for fast access
let enemy_id: usize = rm_guard.add_mesh_entry("characters", MeshEntryDesc {
    name: "enemy".into(),
    lods: vec![MeshLODDesc { lod_index: 0, submeshes: vec![...] }],
})?;

// Add a new LOD level to existing entry (use entry_id, not name)
let hero_id = mesh.mesh_entry_id("hero").unwrap();
let lod1_idx: usize = rm_guard.add_mesh_lod("characters", hero_id, MeshLODDesc {
    lod_index: 1,  // LOD 1 (lower detail)
    submeshes: vec![SubMeshDesc {
        name: "body_lod1".into(),
        vertex_offset: 5000, vertex_count: 2000,
        index_offset: 15000, index_count: 6000,
        topology: PrimitiveTopology::TriangleList,
    }],
})?;

// Add a submesh to existing LOD (use entry_id)
let cape_id: usize = rm_guard.add_submesh("characters", hero_id, 0, SubMeshDesc {
    name: "cape".into(),
    vertex_offset: 7000,
    vertex_count: 500,
    index_offset: 21000,
    index_count: 1500,
    topology: PrimitiveTopology::TriangleList,
})?;

// Fast access using stored ids
let cape = mesh.submesh(hero_id, 0, cape_id).unwrap();</code></pre>
                    </div>
                </div>

                <div class="note">
                    <strong>Rendering with Meshes:</strong> Use <code>mesh.vertex_buffer()</code> and <code>mesh.index_buffer()</code> to get GPU buffers for binding. SubMesh provides offsets and counts for draw calls. Use <code>mesh.is_indexed()</code> to choose between <code>draw()</code> and <code>draw_indexed()</code>.
                </div>
            </section>
        </main>
    </div>

    <footer>
        <p>&copy; 2026 Galaxy3DEngine - Rust Multi-API 3D Rendering Engine</p>
        <p>Generated Documentation</p>
    </footer>

    <script>
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            const header = content.previousElementSibling;

            // Close all other accordions
            document.querySelectorAll('.accordion-content').forEach(el => {
                if (el.id !== id) {
                    el.classList.remove('active');
                    el.previousElementSibling.classList.remove('active');
                }
            });

            // Toggle current accordion
            content.classList.toggle('active');
            header.classList.toggle('active');
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const toggle = event.target;

            section.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
    </script>
</body>
</html>
